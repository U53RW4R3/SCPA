# Current Privileges

## Scripting

### Batch

```batch
@echo off
goto check_admin

:check_admin
echo Administrative permissions required. Detecting permissions...

net.exe session >nul 2>&1
if %errorLevel% == 0 (
    echo Success: Administrative permissions confirmed.
) else (
    echo Failure: Current permissions inadequate.
)
```

## WinAPI

### C

```c
#include <stdio.h>
#include <windows.h>
#include <shellapi.h>

int main() {
    if (IsUserAnAdmin()) {
        printf("You are an Administrator!\n");
    } else {
        printf("Elevated privileges are required!");
    }

    return 0;
}
```

You can load the `shell32.dll` library file to call the function.

```c
#include <stdio.h>
#include <windows.h>
#include <libloaderapi.h>

#pragma comment(lib, "kernel32.lib")

typedef BOOL (WINAPI *IsUserAnAdminFunc)();

int main() {
	HINSTANCE handle_module = LoadLibrary("C:\\WINDOWS\\System32\\shell32.dll");
    if (handle_module == nullptr) {
        printf("Failed to load shell32.dll\n");
        return 1;
    }

	IsUserAnAdminFunc IsUserAnAdmin = (IsUserAnAdminFunc)GetProcAddress(handle_module, "IsUserAnAdmin");

    if (IsUserAnAdmin == nullptr) {
        printf("Failed to locate IsUserAnAdmin function.\n");
        FreeLibrary(handle_module);
        return 1;
    }

    BOOL value = IsUserAnAdmin();
    if (value) {
        printf("You are an Administrator!\n");
    } else {
        printf("Elevated privileges are required!\n");
    }

    FreeLibrary(handle_module);

    return 0;
}
```

Compile the payload.

```
$ x86_64-w64-mingw32-gcc -l kernel32 -l shell32 -o payload.exe payload.c
```

```c
#include <stdio.h>
#include <windows.h>

BOOL isUserElevated() {
    BOOL isElevated = FALSE;
    HANDLE handle_token;
    TOKEN_ELEVATION elevation;
    DWORD size;
    if(OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &token)) {
        if(GetTokenInformation(handle_token, TokenElevation, &elevation, sizeof(elevation), &size))
            isElevated = elevation.TokenIsElevated;
    }

    if(handle_token) {
        CloseHandle(handle_token);
        handle_token = NULL;
    }
    return isElevated;
}

// Disable defender via registry
int main() {
    if(!isUserElevated()) {
        printf("Run as administrator!\n");
        return -1;
    }
    
    return 0;
}
```

### C++

```cpp
#include <iostream>
#include <windows.h>
#include <shellapi.h>

int main() {
    if (IsUserAnAdmin()) {
        std::cout << "You are an Administrator!" << std::endl;
    } else {
	    std::cerr << "Elevated privileges are required!" << std::endl;
    }

    return 0;
}
```

You can load the `shell32.dll` library file to call the function.

```cpp
#include <iostream>
#include <windows.h>

typedef BOOL (WINAPI *pIsUserAnAdmin)();

int main() {
	HINSTANCE handle_module = ::LoadLibrary("C:\\WINDOWS\\System32\\shell32.dll");
    if (handle_module == NULL) {
        std::cerr << "Failed to load shell32.dll" << std::endl;
        return 1;
    }

	pIsUserAnAdmin IsUserAnAdmin = (pIsUserAnAdmin)GetProcAddress(handle_module, "IsUserAnAdmin");

    if (IsUserAnAdmin == NULL) {
        std::cerr << "Failed to locate IsUserAnAdmin function." << std::endl;
        ::FreeLibrary(handle_module);
        return 1;
    }

    BOOL value = IsUserAnAdmin();
    if (IsUserAnAdmin()) {
        std::cout << "You are an Administrator!" << std::endl;
    } else {
	    std::cerr << "Elevated privileges are required!" << std::endl;
    }

    ::FreeLibrary(handle_module);

    return 0;
}
```

Compile the payload.

```
$ x86_64-w64-mingw32-g++ -l shell32 -o payload.exe payload.cpp
```

### C\#

```cs
[DllImport("shell32.dll", SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)]
private static extern bool IsUserAnAdmin();

static bool IsCurrentProcessAdmin() {
    return IsUserAnAdmin();
}
```

### Python

```python
import ctypes

shell32 = ctypes.windll.shell32
IsUserAnAdmin = shell32.IsUserAnAdmin

def is_elevated() -> bool:
    if IsUserAnAdmin() == 1:
        return True
    else:
        return False

if __name__ == "__main__":
    if not is_elevated():
        print("Elevated privileges are required!")
```

## .NET

### C\#

```cs
public bool IsCurrentProcessAdmin() {
    using var identity = System.Security.Principal.WindowsIdentity.GetCurrent();
    var principal = new System.Security.Principal.WindowsPrincipal(identity);
    return principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator);
}
```

https://www.meziantou.net/check-if-the-current-user-is-an-administrator.htm

```cs
// Account centers
public static string Accucenters() {
    WindowsIdentity current = WindowIdentity.GetCurrent();
    WindowsPrincipal windowsprincipal = new WindowsPrincipal(current);
    if (windowsprincipal.IsInRole(WindowsBuiltInRole.Administrator)) {
        return "Admin";
    } else if (windowsprincipal.IsInRole(WindowsBuiltInRole.User)) {
        return "User";
    } else if (windowsprincipal.IsInRole(WindowsBuiltInRole.Guest)) {
        return "Guest";
    }
    return "Unknown";
}
```

### PowerShell

```powershell
function Test-Administrator {
    $user = [Security.Principal.WindowsIdentity]::GetCurrent()
    (New-Object Security.Principal.WindowsPrincipal $user).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
}

if (!Test-Administrator) {
	Write-Output "Elevated privileges are required!"
	Exit()
}
```

---
## References

### Source Repositories

- [Jakoby: If-Admin](https://github.com/I-Am-Jakoby/PowerShell-for-Hackers/blob/main/Functions/If-Admin.md)

### Tenouk

- [Tenouk: Windows DLL - A Supplementary Note](https://www.tenouk.com/cbbccfunction.html)

### Raccoon Ninja

- [Raccoon Ninja: Using Python to check if the application is running as an Administrator](https://raccoon.ninja/post/dev/using-python-to-check-if-the-application-is-running-as-an-administrator/)

### InfoSec Matter

- [InfoSec Matter: Powershell Commands for Pentesters](https://www.infosecmatter.com/powershell-commands-for-pentesters/)