---
author(s):
  - Userware
tags:
  - malware-development
  - networking
---
# CIDR Formatting

## Python

```python
import sys

def cidr_to_regex(cidr):
    ip, prefix = cidr.split('/')

    base = 0
    for val in map(int, ip.split('.')):
        base = (base << 8) | val

    shift = 32 - int(prefix)
    start = base >> shift << shift
    end = start | (1 << shift) - 1

    def regex(lower, upper):
        if lower == upper:
            return str(lower)

        from math import log10
        exp = int(log10(upper - lower))
        delta = 10 ** exp

        if lower == 0 and upper == 255:
            return "\d+"

        if delta == 1:
            val = ""
            for a, b in zip(str(lower), str(upper)):
                if a == b:
                    val += str(a)
                elif (a, b) == ("0", "9"):
                    val += '\d'
                elif int(b) - int(a) == 1:
                    val += '[%s%s]' % (a, b)
                else:
                    val += '[%s-%s]' % (a, b)
            return val

        def gen_classes():
            floor_ = lambda x: int(round(x / delta, 0) * delta)

            xs = range(floor_(upper) - delta, floor_(lower), -delta)
            for x in map(str, xs):
                yield '%s%s' % (x[:-exp], r'\d' * exp)

            yield regex(lower, floor_(lower) + (delta - 1))
            yield regex(floor_(upper), upper)

        return '|'.join(gen_classes())

    def get_parts():
        for x in range(24, -1, -8):
            yield regex(start >> x & 255, end >> x & 255)

    return '^%s$' % r'\.'.join(get_parts())

for line in sys.stdin.readlines():
    print(cidr_to_regex(line))
    print()
```

## Perl

```perl
#!/usr/bin/perl -w

use strict;

my $target;
if ($ARGV[0] =~ m{^\d+}) {
    $target = + shift @ARGV;
}


my $map = [];

sub record($) 
{
    my $v = shift;

    my $m = $map;
    for my $i ( 0 .. 31 ) {
        my $k = $v & (1 << (31-$i));
        $m = $m->[!!$k] ||= (($i == 31) ? $v : []);
    }
}

while (<>) {
    chomp;

    if (m{^\s*(\d+)\.(\d+)\.(\d+)\.(\d+)\s*\z}) {
        if (($1 < 256) && ($2 < 256) && ($3 < 256) && ($4 < 256)) {
            record(($1<<24) | ($2<<16) | ($3 << 8) | $4);
            next;
        }
    }

    printf("Invalid: %s\n", $_);
}

sub output($$$) {
    my ($addr, $bits, $indent) = @_;
    printf "%*s%d.%d.%d.%d",
           $indent*4, '',
           0xff & ($addr >> 24),
           0xff & ($addr >> 16),
           0xff & ($addr >>  8),
           0xff & ($addr      );
    printf("/%d", $bits) if $bits < 32;
    print "\n";
}

sub walk($$$$);
sub walk($$$$) {
    my ($prefix, $bits, $indent, $m) = @_;
    #printf ("%d %d %d ...\n", $prefix, $bits, $indent);
    if ($bits == ($target//-1)) {
        output $prefix<<(32-$bits), $bits, 0;
    } elsif ($bits == 32) { 
        warn 'mismatch '.$prefix.' != '.$m unless $prefix == $m;
        output $prefix, $bits, $indent unless defined $target;
    } elsif (defined $m->[0]) {
        if (defined $m->[1]) {
            output $prefix<<(32-$bits), $bits, $indent unless defined $target;
            walk($prefix*2,   $bits+1, $indent+1, $m->[0]);
            walk($prefix*2+1, $bits+1, $indent+1, $m->[1]);
        } else {
            walk($prefix*2,   $bits+1, $indent, $m->[0]);
        }
    } else {
        if (defined $m->[1]) {
            walk($prefix*2+1, $bits+1, $indent, $m->[1]);
        } else {
            warn sprintf('Empty node at prefix=%x bits=%d indent=%d', $prefix, $bits, $indent);
        }
    }
}

walk (0, 0, 0, $map);
```

To execute in the syntax form.

```
$ chmod +x list2cidr.pl

$ ./list2cidr.pl <CIDR> ips.txt
```

---
## References

### Source Repositories

- [waffle2k: cidr2regex](https://gist.github.com/waffle2k/2294250)

### StackExchange

- [StackExchange: Convert List of IP Into Fixed CIDR Form](https://unix.stackexchange.com/questions/671839/convert-list-of-ip-into-fixed-cidr-form)