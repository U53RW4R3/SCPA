# Types of Address Instructions

## Three Address Instruction

Pseudo code of $X = (A + B) \times (C + D)$ with the following:

```
ADD R1, A, B    ; Perform A + B
ADD R2, C, D    ; Perform C + D
MUL X, R1, R2   ; X = (A + B) * (C + D)
```

In the **CPU Simulator** to demonstrate in assembly:

```
MOV #2, R00    ; R00 <- 2
MOV #5, R01    ; R01 <- 5
```

In the **CPU Simulator** to demonstrate in assembly:

```
ADD R00, R01    ; R00 + R01 -> (Perform 2 + 5)
```

The final code:

```
MOV #2, R00
MOV #5, R01
ADD R00, R01
```

Now the final code needs to be properly exited. First after the operation of the arithmetic value. The program must be ended properly.

We need to store the final register in our case it's `R01` then end it with `0`:

```
STB R01, 0
```

Then exit the program using halt (`HLT`)

```
HTL
```

The final code:

```
MOV #2, R00
MOV #5, R01
ADD R00, R01
STB R01, 0
HLT
```

In NASM the [scratch registers](https://www.cs.uaf.edu/2017/fall/cs301/reference/x86_64.html) with just `rdx`, `r8` to `r11` for sake of consistency to declare and store registers.

## Two Address Instruction

Pseudo code of $X = (A + B) \times (C + D)$:

```
MOV R1, A   ; R1 <- M[A]
ADD R1, B   ; R1 <- R1 + M[B] (Perform A + B)
MOV R2, C   ; R2 <- M[C]
ADD R2, D   ; R2 <- R2 + M[D] (Perform C + D)
MUL R1, R2  ; R1 <- R1 * R2 (Perform (A + B) * (C + D))
MOV X, R1   ; M[X] <- R1 (X = (A + B) * (C + D))
```

## One Address Instruction

We'll be using `LOAD` and `STORE` for the one address instruction that stores in **`AC` (Accumlator).**

Pseudo code of $X = (A + B) \times (C + D)$ with the following::

```
LOAD A      ; AC <- M[A]
ADD B       ; AC <- AC + M[B] (Perform A + B)
STORE T     ; M[T] <- AC (Temporary stores A + B)
LOAD C      ; AC <- M[C]
ADD D       ; AC <- AC + M[D] (Perform C + D)
MUL T       ; AC <- AC * M[T] (Perform (A + B) * (C + D))
MOV X       ; M[X] <- AC
```

## Zero Address Instruction

Using `PUSH` and `POP` for zero address instruction.

Pseudo code of $X = (A + B) \times (C + D)$ with the following::

|Top of Stack (TOS)|
|------------------|
|B|
|A|

```
PUSH A      ; TOS <- M[A]
PUSH B      ; TOS <- M[B]
ADD         ; TOS <- Perform A + B
```

|Top of Stack (TOS)|
|------------------|
|C|
|D|
|A + B|

```
PUSH C      ; TOS <- M[C]
PUSH D      ; TOS <- M[D]
ADD         ; TOS <- Perform C + D
```

|Top of Stack (TOS)|
|------------------|
|C + D|
|A + B|

```
MUL         ; TOS <- Perform ((A + B) * (C + D))
POP X       ; M[X] <- TOS
```

The full pseudo code:

```
PUSH A      ; TOS <- M[A]
PUSH B      ; TOS <- M[B]
ADD         ; TOS <- Perform A + B
PUSH C      ; TOS <- M[C]
PUSH D      ; TOS <- M[D]
ADD         ; TOS <- Perform C + D
MUL         ; TOS <- Perform ((A + B) * (C + D))
POP X       ; M[X] <- TOS
```

---
## References

- [GeeksForGeeks: Computer Organization | Instruction Formats (Zero, One, Two and Three Address Instruction)](https://www.geeksforgeeks.org/computer-organization-instruction-formats-zero-one-two-three-address-instruction/)

https://teach-sim.com/

https://gist.github.com/justinian/385c70347db8aca7ba93e87db90fc9a6

https://www.cs.uaf.edu/2005/fall/cs301/support/x86/nasm.html

https://github.com/Siedler/NASM-Assembly-Cheat-Sheet/blob/master/Cheat-Sheet.md

https://www.docsity.com/en/nasm-intel-x86-assembly-language-cheat-sheet/7381691/

https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

https://labs.bilimedtech.com/nasm/resources/resources.html