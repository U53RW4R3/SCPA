---
author(s):
  - Userware
tags:
  - helpers
  - shellcode
---
# Scripts

## 01 - Python

Formatting assembly binaries into a hexadecimal format.

```python
#!/usr/bin/env python3  
import sys  
  
def hex_format(filename):
    try:  
        with open(filename, "rb") as file:
            shellcode = file.read()
    except FileNotFoundError:  
        print(f"File not Found: {filename}")  
        return  
  
    print(f"Payload size: {len(shellcode)}")  
    print('{ 0x' + ', 0x'.join(hex(i)[2:] for i in shellcode) + ' };')

hex_format(sys.argv[1])
```

Formatting IP address and port into a hexadecimal format.

```python
#!/usr/bin/python3
import socket
import struct
import argparse

option = argparse.ArgumentParser(description="Convert LHOST and LPORT Into there Valid Hex format for Assembly")
option.add_argument("-i","--ip_address", required=False, help="IPV4 Address or LHOST of the Revshell Listener", type=str, default="10.10.14.4")
option.add_argument("-p","--port_number", required=False, help="Port Number or LPORT of the Revshell Listener", type=int, default=8443)

args = option.parse_args()

def ipv4_to_hex(ip_address):
    # Convert the IPv4 address to packed binary format
    packed_ip = socket.inet_aton(ip_address)
    # Convert the packed binary format to hexadecimal and reverse the order of bytes
    hex_ip = struct.unpack("!I", packed_ip)[0]
    reversed_ip = int.from_bytes(hex_ip.to_bytes(4, 'big'), 'little')
    return reversed_ip

def port_to_hex(port):
    # Convert port number to hexadecimal and reverse the order of bytes
    hex_port = struct.pack("!H", port)
    reversed_port = int.from_bytes(hex_port, 'little')
    return reversed_port

hex_ip = ipv4_to_hex(args.ip_address)
hex_port = port_to_hex(args.port_number)

print(f"IP Address: {args.ip_address} -> Hex-Flip: 0x{hex_ip:X}")
print(f"Port: {args.port_number} -> Port-Flip: 0x{hex_port:X}")
```

## 02 - Perl

Formatting assembly binaries into a hexadecimal format.

```perl
#!/usr/bin/env perl

sub hex_format {
    my $filename = $_[0];
    open(my $FILE, "<$filename") or die("Cannot open file $filename\n");
    binmode($FILE);
    my $count = 0;
    my $hexadecimal;

    while (read $FILE, my $data, 1) {
        $hexadecimal .= sprintf(" 0x%02x,", ord($data));
        $count++;
    }
    close($FILE);
    print "Payload size: $count\n";
    print chr(123);
    print "$hexadecimal";
    print chr(125) . chr(59);
}

hex_format($ARGV[0]);
```

## 03 - Golang

Formatting assembly binaries into a hexadecimal format.

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func hexFormat(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()

	stats, statsErr := file.Stat()
	if statsErr != nil {
		fmt.Println(statsErr)
		return
	}

	var size int64 = stats.Size()
	bytes := make([]byte, size)

	bufr := bufio.NewReader(file)
	_, err = bufr.Read(bytes)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Print("{ ")
	for i := 0; i < len(bytes); i++ {
		if i < len(bytes)-1 {
			fmt.Printf("0x%02x, ", bytes[i])
		} else {
		 fmt.Printf("0x%02x };\n", bytes[i])
		}
	}
}

func main() {
	filename := os.Args[1]
	hexFormat(filename)
}
```

---
## References

- [OreoByte: Cookies and Scripts - pen_testing](https://github.com/OreoByte/cookies_and_scripts/tree/main/pen_testing)