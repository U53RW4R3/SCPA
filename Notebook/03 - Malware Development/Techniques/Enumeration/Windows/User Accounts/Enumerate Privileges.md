# Enumerate Privileges

## Current Privileges

### WinAPI

#### C

```c
#include <stdio.h>
#include <windows.h>
#include <shellapi.h>

int main() {
    if (IsUserAnAdmin()) {
        printf("You are an Administrator!\n");
    } else {
        printf("Elevated privileges are required!");
    }

    return 0;
}
```

You can load the `shell32.dll` library file to call the function.

```c
#include <stdio.h>
#include <windows.h>
#include <libloaderapi.h>

#pragma comment(lib, "kernel32.lib")

typedef BOOL (WINAPI *IsUserAnAdminFunc)();

int main() {
	HINSTANCE handle_module = LoadLibrary("C:\\WINDOWS\\system32\\shell32.dll");
    if (handle_module == nullptr) {
        printf("Failed to load shell32.dll\n");
        return 1;
    }

	IsUserAnAdminFunc IsUserAnAdmin = (IsUserAnAdminFunc)GetProcAddress(handle_module, "IsUserAnAdmin");

    if (IsUserAnAdmin == nullptr) {
        printf("Failed to locate IsUserAnAdmin function.\n");
        FreeLibrary(handle_module);
        return 1;
    }

    BOOL value = IsUserAnAdmin();
    if (value) {
        printf("You are an Administrator!\n");
    } else {
        printf("Elevated privileges are required!\n");
    }

    FreeLibrary(handle_module);

    return 0;
}
```

Compile the implant.

```
$ x86_64-w64-mingw32-gcc -l kernel32 -l shell32 -o implant.exe implant.c
```

```c
#include <stdio.h>
#include <windows.h>

BOOL isUserElevated() {
    BOOL isElevated = FALSE;
    HANDLE handle_token;
    TOKEN_ELEVATION elevation;
    DWORD size;
    if(OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &token)) {
        if(GetTokenInformation(handle_token, TokenElevation, &elevation, sizeof(elevation), &size))
            isElevated = elevation.TokenIsElevated;
    }

    if(handle_token) {
        CloseHandle(handle_token);
        handle_token = NULL;
    }
    return isElevated;
}

// Disable defender via registry
int main() {
    if(!isUserElevated()) {
        printf("Run as administrator!\n");
        return -1;
    }
    
    return 0;
}
```

#### C++

```cpp
#include <iostream>
#include <windows.h>
#include <shellapi.h>

int main() {
    if (IsUserAnAdmin()) {
        std::cout << "You are an Administrator!" << std::endl;
    } else {
	    std::cerr << "Elevated privileges are required!" << std::endl;
    }

    return 0;
}
```

You can load the `shell32.dll` library file to call the function.

```cpp
#include <iostream>
#include <windows.h>

typedef BOOL (WINAPI *pIsUserAnAdmin)();

int main() {
	HINSTANCE handle_module = ::LoadLibrary("C:\\WINDOWS\\system32\\shell32.dll");
    if (handle_module == NULL) {
        std::cerr << "Failed to load shell32.dll" << std::endl;
        return 1;
    }

	pIsUserAnAdmin IsUserAnAdmin = (pIsUserAnAdmin)GetProcAddress(handle_module, "IsUserAnAdmin");

    if (IsUserAnAdmin == NULL) {
        std::cerr << "Failed to locate IsUserAnAdmin function." << std::endl;
        ::FreeLibrary(handle_module);
        return 1;
    }

    BOOL value = IsUserAnAdmin();
    if (IsUserAnAdmin()) {
        std::cout << "You are an Administrator!" << std::endl;
    } else {
	    std::cerr << "Elevated privileges are required!" << std::endl;
    }

    ::FreeLibrary(handle_module);

    return 0;
}
```

Compile the implant.

```
$ x86_64-w64-mingw32-g++ -l shell32 -o implant.exe implant.cpp
```

#### C\#

```csharp
[DllImport("shell32.dll", SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)]
private static extern bool IsUserAnAdmin();

static bool IsCurrentProcessAdmin() {
    return IsUserAnAdmin();
}
```

#### Python

```python
import ctypes

shell32 = ctypes.windll.shell32
IsUserAnAdmin = shell32.IsUserAnAdmin

def is_elevated() -> bool:
    if IsUserAnAdmin() == 1:
        return True
    else:
        return False

if __name__ == "__main__":
    if not is_elevated():
        print("Elevated privileges are required!")
```

### .NET

#### C\#

```csharp
public bool IsCurrentProcessAdmin() {
    using var identity = System.Security.Principal.WindowsIdentity.GetCurrent();
    var principal = new System.Security.Principal.WindowsPrincipal(identity);
    return principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator);
}
```

https://www.meziantou.net/check-if-the-current-user-is-an-administrator.htm

```cs
// Account centers
public static string Accucenters() {
    WindowsIdentity current = WindowIdentity.GetCurrent();
    WindowsPrincipal windowsprincipal = new WindowsPrincipal(current);
    if (windowsprincipal.IsInRole(WindowsBuiltInRole.Administrator)) {
        return "Admin";
    } else if (windowsprincipal.IsInRole(WindowsBuiltInRole.User)) {
        return "User";
    } else if (windowsprincipal.IsInRole(WindowsBuiltInRole.Guest)) {
        return "Guest";
    }
    return "Unknown";
}
```

#### PowerShell

```powershell
function Test-Administrator {
    $user = [Security.Principal.WindowsIdentity]::GetCurrent()
    (New-Object Security.Principal.WindowsPrincipal $user).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
}

if (!Test-Administrator) {
	Write-Output "Elevated privileges are required!"
	Exit()
}
```

---
## References

- [Tenouk: Windows DLL - A Supplementary Note](https://www.tenouk.com/cbbccfunction.html)