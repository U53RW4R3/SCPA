# Spawn Process

## C

```c
#include <stdio.h>
#include <windows.h>
#include <errhandlingapi.h>

#pragma comment(lib, "kernel32.lib")

int main() {
    // Create process information structure
    PROCESS_INFORMATION process_information;
    
    // Create startup information structure
    STARTUPINFO startupinfo;
    ZeroMemory(&startupinfo, sizeof(startupinfo));
    startupinfo.cb = sizeof(startupinfo);
    
    // Specify the command to be executed
    TCHAR command[] = TEXT("notepad.exe");

    printf("[*] Spawning process...")
    // Spawn a new process
    if (!CreateProcessA(NULL, command, NULL, NULL, FALSE, 0, NULL, NULL, &startupinfo, &process_information)) {
        printf("[-] Failed to create a process. Error code: %s\n", GetLastError());
        return 1;
    }
    
    printf("[+] Process spawned!");
    
    // Wait for the process to finish executing
    WaitForSingleObject(process_information.hProcess, INFINITE);
    
    // Close process and thread handles
    CloseHandle(process_information.hProcess);
    CloseHandle(process_information.hThread);
    
    return 0;
}
```

## VBA

```vb
Private Declare PtrSafe Function CreateProcessA Lib "kernel32" ( _
    ByVal lpApplicationName As String, ByVal lpCommandLine As String, _
    ByVal lpProcessAttributes As LongPtr, ByVal lpThreadAttributes As LongPtr, _
    ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, _
    ByVal lpEnvironment As LongPtr, ByVal lpCurrentDirectory As LongPtr, _
    lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long

Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long

Type PROCESS_INFORMATION
    hProcess As LongPtr
    hThread As LongPtr
    dwProcessID As Long
    dwThreadID As Long
End Type

Type STARTUPINFO
    cb As Long
    lpReserved As LongPtr
    lpDesktop As LongPtr
    lpTitle As LongPtr
    dwX As Long
    dwY As Long
    dwXSize As Long
    dwYSize As Long
    dwXCountChars As Long
    dwYCountChars As Long
    dwFillAttribute As Long
    dwFlags As Long
    wShowWindow As Integer
    cbReserved2 As Integer
    lpReserved2 As LongPtr
    hStdInput As LongPtr
    hStdOutput As LongPtr
    hStdError As LongPtr
End Type

Sub SpawnProcess()
    Dim proc As PROCESS_INFORMATION
    Dim start As STARTUPINFO
    Dim ReturnValue As Long

    start.cb = Len(start)

    ReturnValue = CreateProcessA(vbNullString, "notepad.exe", 0, 0, False, 0, 0, 0, start, proc)

    If ReturnValue <> 0 Then
        CloseHandle proc.hProcess
        CloseHandle proc.hThread
    End If
End Sub
```

## Create Suspended Process

### C\#

```csharp
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace SuspendedProcessDemo {
    class Program {
        [StructLayout(LayoutKind.Sequential)]
        struct STARTUPINFO {
            public int cb;
            public IntPtr lpReserved;
            public IntPtr lpDesktop;
            public IntPtr lpTitle;
            public int dwX;
            public int dwY;
            public int dwXSize;
            public int dwYSize;
            public int dwXCountChars;
            public int dwYCountChars;
            public int dwFillAttribute;
            public int dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct PROCESS_INFORMATION {
            public IntPtr hProcess;
            public IntPtr hThread;
            public uint dwProcessId;
            public uint dwThreadId;
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool CreateProcess(
            string lpApplicationName,
            string lpCommandLine,
            IntPtr lpProcessAttributes,
            IntPtr lpThreadAttributes,
            bool bInheritHandles,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);       

        static void Main() {
            STARTUPINFO si = new STARTUPINFO();
            si.cb = Marshal.SizeOf(si);
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();

            string targetProcess = "C:\\Windows\\System32\\notepad.exe";

                CreateProcess(
                targetProcess,
                null,
                IntPtr.Zero,
                IntPtr.Zero,
                false,
                0x00000004, // Suspended mode
                IntPtr.Zero,
                null,
                ref si,
                out pi);          
        }
    }
}
```

---
## References

### Tenouk

- [Tenouk: Processes and Threads - WinAPI - Part 6](https://www.tenouk.com/ModuleU.html)

- [Tenouk: Processes and Threads - WinAPI - Part 9](https://www.tenouk.com/ModuleU3.html)

- [Tenouk: Processes and Threads - Synchronization - Part 1](https://www.tenouk.com/ModuleV.html)

### Cocomelonc

- [Cocomelonc: Simple C++ reverse shell for windows](https://cocomelonc.github.io/tutorial/2021/09/15/simple-rev-c-1.html)

### sid4hack

- [RED TEAM: Malware Development - Part 3](https://sid4hack.medium.com/malware-development-part-3-669bebef79c4)

### RootFu

- [RootFu: Creating a Suspended Process in C#](https://rootfu.in/creating-a-suspended-process-in-c/)