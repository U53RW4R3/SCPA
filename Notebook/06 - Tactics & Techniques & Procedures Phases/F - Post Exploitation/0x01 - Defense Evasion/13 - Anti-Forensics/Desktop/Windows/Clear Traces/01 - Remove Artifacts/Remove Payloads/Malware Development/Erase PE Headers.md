# Erase PE Headers

## WinAPI

```c
#include <windows.h>
#include <winbase.h>
#include <libloaderapi.h>
#include <memoryapi.h>
#include <processthreadsapi.h>

#pragma comment(lib, "kernel32.lib")

void erasePEHeader() {
	// execute base address
	HMODULE handle_module = GetModuleHandleW(NULL);

	if (handle_module == NULL) {
		return;
	}

	IMAGE_DOS_HEADER image_dos_header; // DOS Header struct
	IMAGE_NT_HEADERS64 image_nt_headers; // NT Header struct
	DWORD oldprotect; // Store headers original protection (read only)

	// Read the executable DOS Header
	ReadProcessMemory(GetCurrentProcess(), (LPCVOID)handle_module, &image_dos_header, sizeof(image_dos_header), NULL);

	// NT Header virtual address
	LPCVOID nt_headers_virtual_address = (LPBYTE)handle_module + image_dos_header.e_lfanew;

	// Read the executable NT Headers
	ReadProcessMemory(GetCurrentProcess(), (LPCVOID)handle_module, &image_nt_headers, sizeof(image_dos_header), NULL);

	DWORD size_of_headers = image_nt_headers.OptionalHeader.SizeOfHeaders;

	// Modify the PE headers protection to read and write
	if (VirtualProtect((BYTE*)handle_module, size_of_headers, PAGE_READWRITE, &oldprotect)) {
		// Zero-out the PE headers
		ZeroMemory((BYTE*)handle_module, size_of_headers);

		/*
		// Zero-out the PE headers
		BYTE *pointer_base_address = (BYTE*)handle_module;
		for (int i = 0; i < size_of_headers; i++) {
			pointer_base_address[i] = 0;
		}
		*/

		// Restore the original memory protection
		VirtualProtect(((BYTE*)handle_module, size_of_headers, oldprotect, &oldprotect));
	}
}
```