# Python

```python
import ctypes
from ctypes import c_char_p, c_uint32, c_void_p, create_string_buffer
import os.path

# Windows API constants
MAX_PATH = 260
MB_OK = 0x00000000
MB_ICONINFORMATION = 0x00000040

# Load DLLs
kernel32 = ctypes.windll.kernel32
user32 = ctypes.windll.user32

# Define function prototypes
GetCurrentProcessId = kernel32.GetCurrentProcessId
GetCurrentProcessId.restype = c_uint32
GetCurrentProcessId.argtypes = []

GetModuleFileNameA = kernel32.GetModuleFileNameA
GetModuleFileNameA.restype = c_uint32
GetModuleFileNameA.argtypes = [c_void_p, ctypes.c_char_p, c_uint32]

MessageBoxA = user32.MessageBoxA
MessageBoxA.restype = ctypes.c_int32
MessageBoxA.argtypes = [c_void_p, c_char_p, c_char_p, c_uint32]

# Get process ID using Windows API
process_id = GetCurrentProcessId()

# Get process name using Windows API
buffer = create_string_buffer(MAX_PATH)
path_length = GetModuleFileNameA(None, buffer, MAX_PATH)
if path_length == 0:
    raise Exception("Failed to get module filename")

# Convert buffer to string and get just the filename
full_path = buffer.value.decode('ascii')
process_name = os.path.basename(full_path)

message = f"Process Name: {process_name}\nProcess ID: {process_id}"

MessageBoxA(
    None,
    message.encode('ascii'),
    b"Process Information",c
    MB_OK | MB_ICONINFORMATION
)
```

---
## References

### TrustedSec

- [TrustedSec: Operating Inside the Interpreted - Offensive Python](https://trustedsec.com/blog/operating-inside-the-interpreted-offensive-python)