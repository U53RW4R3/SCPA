# CPP

## SHA256

```cpp
#include <windows.>
#include <wincrypt.h>

std::string get_sha256(const std::string& input) {
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    std::vector<BYTE> buffer;
    DWORD cbHash = 0;
    DWORD dwBufferLen = 0;
    std::string hash_string;

    if (!::CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        return "";
    }

    if (!::CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
        ::CryptReleaseContext(hProv, 0);
        return "";
    }

    if (!::CryptHashData(hHash, reinterpret_cast<const BYTE*>(input.c_str()), input.length(), 0)) {
        ::CryptDestroyHash(hHash);
        ::CryptReleaseContext(hProv, 0);
        return "";
    }

    if (!::CryptGetHashParam(hHash, HP_HASHSIZE, reinterpret_cast<BYTE*>(&cbHash), &dwBufferLen, 0)) {
        ::CryptDestroyHash(hHash);
        ::CryptReleaseContext(hProv, 0);
        return "";
    }

    buffer.resize(cbHash);

    if (!::CryptGetHashParam(hHash, HP_HASHVAL, &buffer[0], &cbHash, 0)) {
        ::CryptDestroyHash(hHash);
        ::CryptReleaseContext(hProv, 0);
        return "";
    }

    std::ostringstream oss;
    for (const auto& byte : buffer) {
        oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    }
    hash_string = oss.str();

    ::CryptDestroyHash(hHash);
    ::CryptReleaseContext(hProv, 0);

    return hash_string;
}

bool strings_equal(const std::string &first_string, const std::string &second_string) {
    return first_string == second_string;
}
```

---
## References

### TrustedSec

- [TrustedSec: Execution Guardrails - No One Likes Unintentional Exposure](https://trustedsec.com/blog/execution-guardrails-no-one-likes-unintentional-exposure)